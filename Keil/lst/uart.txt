; generated by Component: ARM Compiler 5.05 update 1 (build 106) Tool: ArmCC [4d0efa]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\obj\uart.o --asm_dir=.\lst\ --list_dir=.\lst\ --depend=.\obj\uart.d --cpu=Cortex-M0 --apcs=interwork -O0 --diag_suppress=9931 -I..\..\..\Library\CMSIS\Include -I..\..\..\Library\Device\Nuvoton\NUC126\Include -I..\..\..\Library\StdDriver\inc -I..\..\..\NUC126_Series_BSP_CMSIS_V3.00.005\Library\StdDriver\inc -I..\..\..\NUC126_Series_BSP_CMSIS_V3.00.005\Library\Device\Nuvoton\NUC126\Include -I..\..\..\NUC126_Series_BSP_CMSIS_V3.00.005\Library\CMSIS\Include -IC:\Keil_v5\ARM\RV31\INC -IC:\Keil_v5\ARM\CMSIS\Include -D__MICROLIB -D__UVISION_VERSION=514 --omf_browse=.\obj\uart.crf ..\..\..\NUC126_Series_BSP_CMSIS_V3.00.005\Library\StdDriver\src\uart.c]
                          THUMB

                          AREA ||i.CLK_GetPLLClockFreq||, CODE, READONLY, ALIGN=2

                  CLK_GetPLLClockFreq PROC
;;;388      */
;;;389    __STATIC_INLINE uint32_t CLK_GetPLLClockFreq(void)
000000  b5fe              PUSH     {r1-r7,lr}
;;;390    {
;;;391        uint32_t u32PllFreq = 0, u32PllReg;
000002  2000              MOVS     r0,#0
000004  9002              STR      r0,[sp,#8]
;;;392        uint32_t u32FIN, u32NF, u32NR, u32NO;
;;;393        uint8_t au8NoTbl[4] = {1, 2, 2, 4};
000006  a01a              ADR      r0,|L1.112|
000008  6800              LDR      r0,[r0,#0]
00000a  9000              STR      r0,[sp,#0]
;;;394    
;;;395        u32PllReg = CLK->PLLCTL;
00000c  4819              LDR      r0,|L1.116|
00000e  6a04              LDR      r4,[r0,#0x20]
;;;396    
;;;397        if(u32PllReg & (CLK_PLLCTL_PD_Msk | CLK_PLLCTL_OE_Msk))
000010  1300              ASRS     r0,r0,#12
000012  4020              ANDS     r0,r0,r4
000014  2800              CMP      r0,#0
000016  d001              BEQ      |L1.28|
;;;398            return 0;           /* PLL is in power down mode or fix low */
000018  2000              MOVS     r0,#0
                  |L1.26|
;;;399    
;;;400        if(u32PllReg & CLK_PLLCTL_PLLSRC_HIRC)
;;;401            u32FIN = __HIRC;    /* PLL source clock from HIRC */
;;;402        else
;;;403            u32FIN = __HXT;     /* PLL source clock from HXT */
;;;404    
;;;405        if(u32PllReg & CLK_PLLCTL_BP_Msk)
;;;406            return u32FIN;      /* PLL is in bypass mode */
;;;407    
;;;408        /* PLL is output enabled in normal work mode */
;;;409        u32NO = au8NoTbl[((u32PllReg & CLK_PLLCTL_OUTDIV_Msk) >> CLK_PLLCTL_OUTDIV_Pos)];
;;;410        u32NF = ((u32PllReg & CLK_PLLCTL_FBDIV_Msk) >> CLK_PLLCTL_FBDIV_Pos) + 2;
;;;411        u32NR = ((u32PllReg & CLK_PLLCTL_INDIV_Msk) >> CLK_PLLCTL_INDIV_Pos) + 2;
;;;412    
;;;413        /* u32FIN is shifted 2 bits to avoid overflow */
;;;414        u32PllFreq = (((u32FIN >> 2) * u32NF) / (u32NR * u32NO) << 2);
;;;415    
;;;416        return u32PllFreq;
;;;417    }
00001a  bdfe              POP      {r1-r7,pc}
                  |L1.28|
00001c  2001              MOVS     r0,#1                 ;400
00001e  04c0              LSLS     r0,r0,#19             ;400
000020  4020              ANDS     r0,r0,r4              ;400
000022  2800              CMP      r0,#0                 ;400
000024  d001              BEQ      |L1.42|
000026  4d14              LDR      r5,|L1.120|
000028  e000              B        |L1.44|
                  |L1.42|
00002a  4d14              LDR      r5,|L1.124|
                  |L1.44|
00002c  2001              MOVS     r0,#1                 ;405
00002e  0440              LSLS     r0,r0,#17             ;405
000030  4020              ANDS     r0,r0,r4              ;405
000032  2800              CMP      r0,#0                 ;405
000034  d001              BEQ      |L1.58|
000036  4628              MOV      r0,r5                 ;406
000038  e7ef              B        |L1.26|
                  |L1.58|
00003a  2003              MOVS     r0,#3                 ;409
00003c  0380              LSLS     r0,r0,#14             ;409
00003e  4020              ANDS     r0,r0,r4              ;409
000040  0b80              LSRS     r0,r0,#14             ;409
000042  4669              MOV      r1,sp                 ;409
000044  5c0a              LDRB     r2,[r1,r0]            ;409
000046  9201              STR      r2,[sp,#4]            ;409
000048  05e0              LSLS     r0,r4,#23             ;410
00004a  0dc0              LSRS     r0,r0,#23             ;410
00004c  1c86              ADDS     r6,r0,#2              ;410
00004e  201f              MOVS     r0,#0x1f              ;411
000050  0240              LSLS     r0,r0,#9              ;411
000052  4020              ANDS     r0,r0,r4              ;411
000054  0a40              LSRS     r0,r0,#9              ;411
000056  1c87              ADDS     r7,r0,#2              ;411
000058  9a01              LDR      r2,[sp,#4]            ;414
00005a  437a              MULS     r2,r7,r2              ;414
00005c  4611              MOV      r1,r2                 ;414
00005e  08aa              LSRS     r2,r5,#2              ;414
000060  4372              MULS     r2,r6,r2              ;414
000062  4610              MOV      r0,r2                 ;414
000064  f7fffffe          BL       __aeabi_uidivmod
000068  0080              LSLS     r0,r0,#2              ;414
00006a  9002              STR      r0,[sp,#8]            ;414
00006c  9802              LDR      r0,[sp,#8]            ;416
00006e  e7d4              B        |L1.26|
;;;418    
                          ENDP

                  |L1.112|
000070  01020204          DCB      1,2,2,4
                  |L1.116|
                          DCD      0x50000200
                  |L1.120|
                          DCD      0x01518000
                  |L1.124|
                          DCD      0x00a8c000

                          AREA ||i.NVIC_DisableIRQ||, CODE, READONLY, ALIGN=2

                  NVIC_DisableIRQ PROC
;;;639     */
;;;640    __STATIC_INLINE void NVIC_DisableIRQ(IRQn_Type IRQn)
000000  06c2              LSLS     r2,r0,#27
;;;641    {
;;;642      NVIC->ICER[0U] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
000002  0ed2              LSRS     r2,r2,#27
000004  2101              MOVS     r1,#1
000006  4091              LSLS     r1,r1,r2
000008  4a01              LDR      r2,|L2.16|
00000a  6011              STR      r1,[r2,#0]
;;;643    }
00000c  4770              BX       lr
;;;644    
                          ENDP

00000e  0000              DCW      0x0000
                  |L2.16|
                          DCD      0xe000e180

                          AREA ||i.NVIC_EnableIRQ||, CODE, READONLY, ALIGN=2

                  NVIC_EnableIRQ PROC
;;;628     */
;;;629    __STATIC_INLINE void NVIC_EnableIRQ(IRQn_Type IRQn)
000000  06c2              LSLS     r2,r0,#27
;;;630    {
;;;631      NVIC->ISER[0U] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
000002  0ed2              LSRS     r2,r2,#27
000004  2101              MOVS     r1,#1
000006  4091              LSLS     r1,r1,r2
000008  4a01              LDR      r2,|L3.16|
00000a  6011              STR      r1,[r2,#0]
;;;632    }
00000c  4770              BX       lr
;;;633    
                          ENDP

00000e  0000              DCW      0x0000
                  |L3.16|
                          DCD      0xe000e100

                          AREA ||i.UART_ClearIntFlag||, CODE, READONLY, ALIGN=2

                  UART_ClearIntFlag PROC
;;;44      */
;;;45     void UART_ClearIntFlag(UART_T* uart , uint32_t u32InterruptFlag)
000000  2201              MOVS     r2,#1
;;;46     {
;;;47     
;;;48         if(u32InterruptFlag & UART_INTSTS_RLSINT_Msk)       /* Clear Receive Line Status Interrupt */
000002  0292              LSLS     r2,r2,#10
000004  400a              ANDS     r2,r2,r1
000006  2a00              CMP      r2,#0
000008  d001              BEQ      |L4.14|
;;;49             uart->FIFOSTS = UART_FIFOSTS_BIF_Msk | UART_FIFOSTS_FEF_Msk | UART_FIFOSTS_FEF_Msk | UART_FIFOSTS_ADDRDETF_Msk;
00000a  2268              MOVS     r2,#0x68
00000c  6182              STR      r2,[r0,#0x18]
                  |L4.14|
;;;50     
;;;51         if(u32InterruptFlag & UART_INTSTS_MODEMINT_Msk)     /* Clear MODEM Status Interrupt */
00000e  2201              MOVS     r2,#1
000010  02d2              LSLS     r2,r2,#11
000012  400a              ANDS     r2,r2,r1
000014  2a00              CMP      r2,#0
000016  d003              BEQ      |L4.32|
;;;52             uart->MODEMSTS |= UART_MODEMSTS_CTSDETF_Msk;
000018  6942              LDR      r2,[r0,#0x14]
00001a  2301              MOVS     r3,#1
00001c  431a              ORRS     r2,r2,r3
00001e  6142              STR      r2,[r0,#0x14]
                  |L4.32|
;;;53     
;;;54         if(u32InterruptFlag & UART_INTSTS_BUFERRINT_Msk)    /* Clear Buffer Error Interrupt */
000020  2201              MOVS     r2,#1
000022  0352              LSLS     r2,r2,#13
000024  400a              ANDS     r2,r2,r1
000026  2a00              CMP      r2,#0
000028  d001              BEQ      |L4.46|
;;;55             uart->FIFOSTS = UART_FIFOSTS_RXOVIF_Msk | UART_FIFOSTS_TXOVIF_Msk;
00002a  4a09              LDR      r2,|L4.80|
00002c  6182              STR      r2,[r0,#0x18]
                  |L4.46|
;;;56     
;;;57         if(u32InterruptFlag & UART_INTSTS_WKINT_Msk)        /* Clear Wake-up Interrupt */
00002e  2201              MOVS     r2,#1
000030  0392              LSLS     r2,r2,#14
000032  400a              ANDS     r2,r2,r1
000034  2a00              CMP      r2,#0
000036  d001              BEQ      |L4.60|
;;;58             uart->WKSTS = uart->WKSTS;
000038  6c42              LDR      r2,[r0,#0x44]
00003a  6442              STR      r2,[r0,#0x44]
                  |L4.60|
;;;59     
;;;60         if(u32InterruptFlag & UART_INTSTS_LININT_Msk)       /* Clear LIN Bus Interrupt */
00003c  2201              MOVS     r2,#1
00003e  03d2              LSLS     r2,r2,#15
000040  400a              ANDS     r2,r2,r1
000042  2a00              CMP      r2,#0
000044  d003              BEQ      |L4.78|
;;;61         {
;;;62             uart->INTSTS = UART_INTSTS_LINIF_Msk;
000046  2280              MOVS     r2,#0x80
000048  61c2              STR      r2,[r0,#0x1c]
;;;63             uart->LINSTS = uart->LINSTS;
00004a  6b82              LDR      r2,[r0,#0x38]
00004c  6382              STR      r2,[r0,#0x38]
                  |L4.78|
;;;64         }
;;;65     
;;;66     }
00004e  4770              BX       lr
;;;67     
                          ENDP

                  |L4.80|
                          DCD      0x01000001

                          AREA ||i.UART_Close||, CODE, READONLY, ALIGN=1

                  UART_Close PROC
;;;77      */
;;;78     void UART_Close(UART_T* uart)
000000  2100              MOVS     r1,#0
;;;79     {
;;;80         uart->INTEN = 0;
000002  6041              STR      r1,[r0,#4]
;;;81     }
000004  4770              BX       lr
;;;82     
                          ENDP


                          AREA ||i.UART_DisableFlowCtrl||, CODE, READONLY, ALIGN=1

                  UART_DisableFlowCtrl PROC
;;;92      */
;;;93     void UART_DisableFlowCtrl(UART_T* uart)
000000  6841              LDR      r1,[r0,#4]
;;;94     {
;;;95         uart->INTEN &= ~(UART_INTEN_ATORTSEN_Msk | UART_INTEN_ATOCTSEN_Msk);
000002  2203              MOVS     r2,#3
000004  0312              LSLS     r2,r2,#12
000006  4391              BICS     r1,r1,r2
000008  6041              STR      r1,[r0,#4]
;;;96     }
00000a  4770              BX       lr
;;;97     
                          ENDP


                          AREA ||i.UART_DisableInt||, CODE, READONLY, ALIGN=2

                  UART_DisableInt PROC
;;;118     */
;;;119    void UART_DisableInt(UART_T*  uart, uint32_t u32InterruptFlag)
000000  b570              PUSH     {r4-r6,lr}
;;;120    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;121        /* Disable UART specified interrupt */
;;;122        UART_DISABLE_INT(uart, u32InterruptFlag);
000006  6860              LDR      r0,[r4,#4]
000008  43a8              BICS     r0,r0,r5
00000a  6060              STR      r0,[r4,#4]
;;;123    
;;;124        /* Disable NVIC UART IRQ */
;;;125        if(uart == UART0)
00000c  4808              LDR      r0,|L7.48|
00000e  4284              CMP      r4,r0
000010  d103              BNE      |L7.26|
;;;126            NVIC_DisableIRQ(UART02_IRQn);
000012  200c              MOVS     r0,#0xc
000014  f7fffffe          BL       NVIC_DisableIRQ
000018  e009              B        |L7.46|
                  |L7.26|
;;;127        else if(uart == UART1)
00001a  4806              LDR      r0,|L7.52|
00001c  4284              CMP      r4,r0
00001e  d103              BNE      |L7.40|
;;;128            NVIC_DisableIRQ(UART1_IRQn);
000020  200d              MOVS     r0,#0xd
000022  f7fffffe          BL       NVIC_DisableIRQ
000026  e002              B        |L7.46|
                  |L7.40|
;;;129        else
;;;130            NVIC_DisableIRQ(UART02_IRQn);
000028  200c              MOVS     r0,#0xc
00002a  f7fffffe          BL       NVIC_DisableIRQ
                  |L7.46|
;;;131    }
00002e  bd70              POP      {r4-r6,pc}
;;;132    
                          ENDP

                  |L7.48|
                          DCD      0x40050000
                  |L7.52|
                          DCD      0x40150000

                          AREA ||i.UART_EnableFlowCtrl||, CODE, READONLY, ALIGN=1

                  UART_EnableFlowCtrl PROC
;;;151     */
;;;152    void UART_EnableFlowCtrl(UART_T* uart)
000000  6901              LDR      r1,[r0,#0x10]
;;;153    {
;;;154        /* Set RTS pin output is low level active */
;;;155        uart->MODEM |= UART_MODEM_RTSACTLV_Msk;
000002  2201              MOVS     r2,#1
000004  0252              LSLS     r2,r2,#9
000006  4311              ORRS     r1,r1,r2
000008  6101              STR      r1,[r0,#0x10]
;;;156    
;;;157        /* Set CTS pin input is low level active */
;;;158        uart->MODEMSTS |= UART_MODEMSTS_CTSACTLV_Msk;
00000a  6941              LDR      r1,[r0,#0x14]
00000c  1052              ASRS     r2,r2,#1
00000e  4311              ORRS     r1,r1,r2
000010  6141              STR      r1,[r0,#0x14]
;;;159    
;;;160        /* Set RTS and CTS auto flow control enable */
;;;161        uart->INTEN |= UART_INTEN_ATORTSEN_Msk | UART_INTEN_ATOCTSEN_Msk;
000012  6841              LDR      r1,[r0,#4]
000014  2203              MOVS     r2,#3
000016  0312              LSLS     r2,r2,#12
000018  4311              ORRS     r1,r1,r2
00001a  6041              STR      r1,[r0,#4]
;;;162    }
00001c  4770              BX       lr
;;;163    
                          ENDP


                          AREA ||i.UART_EnableInt||, CODE, READONLY, ALIGN=2

                  UART_EnableInt PROC
;;;184     */
;;;185    void UART_EnableInt(UART_T*  uart, uint32_t u32InterruptFlag)
000000  b570              PUSH     {r4-r6,lr}
;;;186    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;187    
;;;188        /* Enable UART specified interrupt */
;;;189        UART_ENABLE_INT(uart, u32InterruptFlag);
000006  6860              LDR      r0,[r4,#4]
000008  4328              ORRS     r0,r0,r5
00000a  6060              STR      r0,[r4,#4]
;;;190    
;;;191        /* Enable NVIC UART IRQ */
;;;192        if(uart == UART0)
00000c  4808              LDR      r0,|L9.48|
00000e  4284              CMP      r4,r0
000010  d103              BNE      |L9.26|
;;;193            NVIC_EnableIRQ(UART02_IRQn);
000012  200c              MOVS     r0,#0xc
000014  f7fffffe          BL       NVIC_EnableIRQ
000018  e009              B        |L9.46|
                  |L9.26|
;;;194        else if(uart == UART1)
00001a  4806              LDR      r0,|L9.52|
00001c  4284              CMP      r4,r0
00001e  d103              BNE      |L9.40|
;;;195            NVIC_EnableIRQ(UART1_IRQn);
000020  200d              MOVS     r0,#0xd
000022  f7fffffe          BL       NVIC_EnableIRQ
000026  e002              B        |L9.46|
                  |L9.40|
;;;196        else
;;;197            NVIC_EnableIRQ(UART02_IRQn);
000028  200c              MOVS     r0,#0xc
00002a  f7fffffe          BL       NVIC_EnableIRQ
                  |L9.46|
;;;198    
;;;199    }
00002e  bd70              POP      {r4-r6,pc}
;;;200    
                          ENDP

                  |L9.48|
                          DCD      0x40050000
                  |L9.52|
                          DCD      0x40150000

                          AREA ||i.UART_Open||, CODE, READONLY, ALIGN=2

                  UART_Open PROC
;;;211     */
;;;212    void UART_Open(UART_T* uart, uint32_t u32baudrate)
000000  b5f0              PUSH     {r4-r7,lr}
;;;213    {
000002  b087              SUB      sp,sp,#0x1c
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
;;;214        uint8_t u8UartClkSrcSel, u8UartClkDivNum;
;;;215        uint32_t u32ClkTbl[4] = {__HXT, 0, __LXT, __HIRC};
000008  4827              LDR      r0,|L10.168|
00000a  4601              MOV      r1,r0
00000c  c90e              LDM      r1,{r1-r3}
00000e  68c0              LDR      r0,[r0,#0xc]  ; <Data1>
000010  ae03              ADD      r6,sp,#0xc
000012  c60e              STM      r6!,{r1-r3}
000014  9006              STR      r0,[sp,#0x18]
;;;216        uint32_t u32Baud_Div = 0;
000016  2000              MOVS     r0,#0
000018  9002              STR      r0,[sp,#8]
;;;217    
;;;218        /* Get UART clock source selection */
;;;219        u8UartClkSrcSel = (CLK->CLKSEL1 & CLK_CLKSEL1_UARTSEL_Msk) >> CLK_CLKSEL1_UARTSEL_Pos;
00001a  4824              LDR      r0,|L10.172|
00001c  6940              LDR      r0,[r0,#0x14]
00001e  2103              MOVS     r1,#3
000020  0609              LSLS     r1,r1,#24
000022  4008              ANDS     r0,r0,r1
000024  0e06              LSRS     r6,r0,#24
;;;220    
;;;221        /* Get UART clock divider number */
;;;222        u8UartClkDivNum = (CLK->CLKDIV0 & CLK_CLKDIV0_UARTDIV_Msk) >> CLK_CLKDIV0_UARTDIV_Pos;
000026  4821              LDR      r0,|L10.172|
000028  6980              LDR      r0,[r0,#0x18]
00002a  210f              MOVS     r1,#0xf
00002c  0209              LSLS     r1,r1,#8
00002e  4008              ANDS     r0,r0,r1
000030  0a07              LSRS     r7,r0,#8
;;;223    
;;;224        /* Select UART function */
;;;225        uart->FUNCSEL = UART_FUNCSEL_UART;
000032  2000              MOVS     r0,#0
000034  6320              STR      r0,[r4,#0x30]
;;;226    
;;;227        /* Set UART line configuration */
;;;228        uart->LINE = UART_WORD_LEN_8 | UART_PARITY_NONE | UART_STOP_BIT_1;
000036  2003              MOVS     r0,#3
000038  60e0              STR      r0,[r4,#0xc]
;;;229    
;;;230        /* Set UART Rx and RTS trigger level */
;;;231        uart->FIFO &= ~(UART_FIFO_RFITL_Msk | UART_FIFO_RTSTRGLV_Msk);
00003a  68a0              LDR      r0,[r4,#8]
00003c  491c              LDR      r1,|L10.176|
00003e  4008              ANDS     r0,r0,r1
000040  60a0              STR      r0,[r4,#8]
;;;232    
;;;233        /* Get PLL clock frequency if UART clock source selection is PLL */
;;;234        if(u8UartClkSrcSel == 1)
000042  2e01              CMP      r6,#1
000044  d104              BNE      |L10.80|
;;;235            u32ClkTbl[u8UartClkSrcSel] = CLK_GetPLLClockFreq();
000046  f7fffffe          BL       CLK_GetPLLClockFreq
00004a  00b1              LSLS     r1,r6,#2
00004c  aa03              ADD      r2,sp,#0xc
00004e  5050              STR      r0,[r2,r1]
                  |L10.80|
;;;236    
;;;237        /* Set UART baud rate */
;;;238        if(u32baudrate != 0)
000050  2d00              CMP      r5,#0
000052  d026              BEQ      |L10.162|
;;;239        {
;;;240            u32Baud_Div = UART_BAUD_MODE2_DIVIDER((u32ClkTbl[u8UartClkSrcSel]) / (u8UartClkDivNum + 1), u32baudrate);
000054  00b1              LSLS     r1,r6,#2
000056  aa03              ADD      r2,sp,#0xc
000058  5850              LDR      r0,[r2,r1]
00005a  1c79              ADDS     r1,r7,#1
00005c  f7fffffe          BL       __aeabi_uidivmod
000060  0869              LSRS     r1,r5,#1
000062  1840              ADDS     r0,r0,r1
000064  4629              MOV      r1,r5
000066  9001              STR      r0,[sp,#4]
000068  f7fffffe          BL       __aeabi_uidivmod
00006c  1e80              SUBS     r0,r0,#2
00006e  9002              STR      r0,[sp,#8]
;;;241    
;;;242            if(u32Baud_Div > 0xFFFF)
000070  4910              LDR      r1,|L10.180|
000072  9802              LDR      r0,[sp,#8]
000074  4288              CMP      r0,r1
000076  d90f              BLS      |L10.152|
;;;243                uart->BAUD = (UART_BAUD_MODE0 | UART_BAUD_MODE0_DIVIDER((u32ClkTbl[u8UartClkSrcSel]) / (u8UartClkDivNum + 1), u32baudrate));
000078  00b1              LSLS     r1,r6,#2
00007a  aa03              ADD      r2,sp,#0xc
00007c  5850              LDR      r0,[r2,r1]
00007e  1c79              ADDS     r1,r7,#1
000080  f7fffffe          BL       __aeabi_uidivmod
000084  00e9              LSLS     r1,r5,#3
000086  1840              ADDS     r0,r0,r1
000088  4629              MOV      r1,r5
00008a  9001              STR      r0,[sp,#4]
00008c  f7fffffe          BL       __aeabi_uidivmod
000090  0900              LSRS     r0,r0,#4
000092  1e80              SUBS     r0,r0,#2
000094  6260              STR      r0,[r4,#0x24]
000096  e004              B        |L10.162|
                  |L10.152|
;;;244            else
;;;245                uart->BAUD = (UART_BAUD_MODE2 | u32Baud_Div);
000098  2103              MOVS     r1,#3
00009a  0709              LSLS     r1,r1,#28
00009c  9802              LDR      r0,[sp,#8]
00009e  4308              ORRS     r0,r0,r1
0000a0  6260              STR      r0,[r4,#0x24]
                  |L10.162|
;;;246        }
;;;247    }
0000a2  b007              ADD      sp,sp,#0x1c
0000a4  bdf0              POP      {r4-r7,pc}
;;;248    
                          ENDP

0000a6  0000              DCW      0x0000
                  |L10.168|
                          DCD      ||.constdata||
                  |L10.172|
                          DCD      0x50000200
                  |L10.176|
                          DCD      0xfff0ff0f
                  |L10.180|
                          DCD      0x0000ffff

                          AREA ||i.UART_Read||, CODE, READONLY, ALIGN=1

                  UART_Read PROC
;;;260     */
;;;261    uint32_t UART_Read(UART_T* uart, uint8_t *pu8RxBuf, uint32_t u32ReadBytes)
000000  b570              PUSH     {r4-r6,lr}
;;;262    {
000002  4603              MOV      r3,r0
000004  460c              MOV      r4,r1
;;;263        uint32_t  u32Count, u32delayno;
;;;264    
;;;265        for(u32Count = 0; u32Count < u32ReadBytes; u32Count++)
000006  2100              MOVS     r1,#0
000008  e011              B        |L11.46|
                  |L11.10|
;;;266        {
;;;267            u32delayno = 0;
00000a  2500              MOVS     r5,#0
;;;268    
;;;269            while(uart->FIFOSTS & UART_FIFOSTS_RXEMPTY_Msk)   /* Check RX empty => failed */
00000c  e006              B        |L11.28|
                  |L11.14|
;;;270            {
;;;271                u32delayno++;
00000e  1c6d              ADDS     r5,r5,#1
;;;272                if(u32delayno >= 0x40000000)
000010  2001              MOVS     r0,#1
000012  0780              LSLS     r0,r0,#30
000014  4285              CMP      r5,r0
000016  d301              BCC      |L11.28|
;;;273                    return FALSE;
000018  2000              MOVS     r0,#0
                  |L11.26|
;;;274            }
;;;275            pu8RxBuf[u32Count] = uart->DAT;    /* Get Data from UART RX  */
;;;276        }
;;;277    
;;;278        return u32Count;
;;;279    
;;;280    }
00001a  bd70              POP      {r4-r6,pc}
                  |L11.28|
00001c  6998              LDR      r0,[r3,#0x18]         ;269
00001e  2601              MOVS     r6,#1                 ;269
000020  03b6              LSLS     r6,r6,#14             ;269
000022  4030              ANDS     r0,r0,r6              ;269
000024  2800              CMP      r0,#0                 ;269
000026  d1f2              BNE      |L11.14|
000028  6818              LDR      r0,[r3,#0]            ;275
00002a  5460              STRB     r0,[r4,r1]            ;275
00002c  1c49              ADDS     r1,r1,#1              ;265
                  |L11.46|
00002e  4291              CMP      r1,r2                 ;265
000030  d3eb              BCC      |L11.10|
000032  4608              MOV      r0,r1                 ;278
000034  e7f1              B        |L11.26|
;;;281    
                          ENDP


                          AREA ||i.UART_SelectIrDAMode||, CODE, READONLY, ALIGN=2

                  UART_SelectIrDAMode PROC
;;;373     */
;;;374    void UART_SelectIrDAMode(UART_T* uart, uint32_t u32Buadrate, uint32_t u32Direction)
000000  b5f7              PUSH     {r0-r2,r4-r7,lr}
;;;375    {
000002  b086              SUB      sp,sp,#0x18
000004  4604              MOV      r4,r0
000006  460e              MOV      r6,r1
;;;376        uint8_t u8UartClkSrcSel, u8UartClkDivNum;
;;;377        uint32_t u32ClkTbl[4] = {__HXT, 0, __LXT, __HIRC};
000008  4823              LDR      r0,|L12.152|
00000a  4601              MOV      r1,r0
00000c  c90e              LDM      r1,{r1-r3}
00000e  68c0              LDR      r0,[r0,#0xc]  ; <Data3>
000010  ad01              ADD      r5,sp,#4
000012  c50e              STM      r5!,{r1-r3}
000014  9004              STR      r0,[sp,#0x10]
;;;378        uint32_t u32Baud_Div;
;;;379    
;;;380        /* Select IrDA function mode */
;;;381        uart->FUNCSEL = UART_FUNCSEL_IrDA;
000016  2002              MOVS     r0,#2
000018  6320              STR      r0,[r4,#0x30]
;;;382    
;;;383        /* Get UART clock source selection */
;;;384        u8UartClkSrcSel = (CLK->CLKSEL1 & CLK_CLKSEL1_UARTSEL_Msk) >> CLK_CLKSEL1_UARTSEL_Pos;
00001a  4820              LDR      r0,|L12.156|
00001c  6940              LDR      r0,[r0,#0x14]
00001e  2103              MOVS     r1,#3
000020  0609              LSLS     r1,r1,#24
000022  4008              ANDS     r0,r0,r1
000024  0e07              LSRS     r7,r0,#24
;;;385    
;;;386        /* Get UART clock divider number */
;;;387        u8UartClkDivNum = (CLK->CLKDIV0 & CLK_CLKDIV0_UARTDIV_Msk) >> CLK_CLKDIV0_UARTDIV_Pos;
000026  481d              LDR      r0,|L12.156|
000028  6980              LDR      r0,[r0,#0x18]
00002a  210f              MOVS     r1,#0xf
00002c  0209              LSLS     r1,r1,#8
00002e  4008              ANDS     r0,r0,r1
000030  0a00              LSRS     r0,r0,#8
000032  9005              STR      r0,[sp,#0x14]
;;;388    
;;;389        /* Get PLL clock frequency if UART clock source selection is PLL */
;;;390        if(u8UartClkSrcSel == 1)
000034  2f01              CMP      r7,#1
000036  d104              BNE      |L12.66|
;;;391            u32ClkTbl[u8UartClkSrcSel] = CLK_GetPLLClockFreq();
000038  f7fffffe          BL       CLK_GetPLLClockFreq
00003c  00b9              LSLS     r1,r7,#2
00003e  aa01              ADD      r2,sp,#4
000040  5050              STR      r0,[r2,r1]
                  |L12.66|
;;;392    
;;;393        /* Set UART IrDA baud rate in mode 0 */
;;;394        if(u32Buadrate != 0)
000042  2e00              CMP      r6,#0
000044  d012              BEQ      |L12.108|
;;;395        {
;;;396            u32Baud_Div = UART_BAUD_MODE0_DIVIDER((u32ClkTbl[u8UartClkSrcSel]) / (u8UartClkDivNum + 1), u32Buadrate);
000046  00b9              LSLS     r1,r7,#2
000048  aa01              ADD      r2,sp,#4
00004a  5850              LDR      r0,[r2,r1]
00004c  9905              LDR      r1,[sp,#0x14]
00004e  1c49              ADDS     r1,r1,#1
000050  f7fffffe          BL       __aeabi_uidivmod
000054  00f1              LSLS     r1,r6,#3
000056  1840              ADDS     r0,r0,r1
000058  4631              MOV      r1,r6
00005a  9000              STR      r0,[sp,#0]
00005c  f7fffffe          BL       __aeabi_uidivmod
000060  0900              LSRS     r0,r0,#4
000062  1e85              SUBS     r5,r0,#2
;;;397    
;;;398            if(u32Baud_Div < 0xFFFF)
000064  480e              LDR      r0,|L12.160|
000066  4285              CMP      r5,r0
000068  d200              BCS      |L12.108|
;;;399                uart->BAUD = (UART_BAUD_MODE0 | u32Baud_Div);
00006a  6265              STR      r5,[r4,#0x24]
                  |L12.108|
;;;400        }
;;;401    
;;;402        /* Configure IrDA relative settings */
;;;403        if(u32Direction == UART_IRDA_RXEN)
00006c  9808              LDR      r0,[sp,#0x20]
00006e  2800              CMP      r0,#0
000070  d108              BNE      |L12.132|
;;;404        {
;;;405            uart->IRDA |= UART_IRDA_RXINV_Msk;     //Rx signal is inverse
000072  6aa0              LDR      r0,[r4,#0x28]
000074  2140              MOVS     r1,#0x40
000076  4308              ORRS     r0,r0,r1
000078  62a0              STR      r0,[r4,#0x28]
;;;406            uart->IRDA &= ~UART_IRDA_TXEN_Msk;
00007a  6aa0              LDR      r0,[r4,#0x28]
00007c  2102              MOVS     r1,#2
00007e  4388              BICS     r0,r0,r1
000080  62a0              STR      r0,[r4,#0x28]
000082  e007              B        |L12.148|
                  |L12.132|
;;;407        }
;;;408        else
;;;409        {
;;;410            uart->IRDA &= ~UART_IRDA_TXINV_Msk;    //Tx signal is not inverse
000084  6aa0              LDR      r0,[r4,#0x28]
000086  2120              MOVS     r1,#0x20
000088  4388              BICS     r0,r0,r1
00008a  62a0              STR      r0,[r4,#0x28]
;;;411            uart->IRDA |= UART_IRDA_TXEN_Msk;
00008c  6aa0              LDR      r0,[r4,#0x28]
00008e  2102              MOVS     r1,#2
000090  4308              ORRS     r0,r0,r1
000092  62a0              STR      r0,[r4,#0x28]
                  |L12.148|
;;;412        }
;;;413    
;;;414    }
000094  b009              ADD      sp,sp,#0x24
000096  bdf0              POP      {r4-r7,pc}
;;;415    
                          ENDP

                  |L12.152|
                          DCD      ||.constdata||+0x20
                  |L12.156|
                          DCD      0x50000200
                  |L12.160|
                          DCD      0x0000ffff

                          AREA ||i.UART_SelectLINMode||, CODE, READONLY, ALIGN=1

                  UART_SelectLINMode PROC
;;;454     */
;;;455    void UART_SelectLINMode(UART_T* uart, uint32_t u32Mode, uint32_t u32BreakLength)
000000  b510              PUSH     {r4,lr}
;;;456    {
;;;457        /* Select LIN function mode */
;;;458        uart->FUNCSEL = UART_FUNCSEL_LIN;
000002  2301              MOVS     r3,#1
000004  6303              STR      r3,[r0,#0x30]
;;;459    
;;;460        /* Select LIN function setting : Tx enable, Rx enable and break field length */
;;;461        uart->ALTCTL &= ~(UART_ALTCTL_LINTXEN_Msk | UART_ALTCTL_LINRXEN_Msk | UART_ALTCTL_BRKFL_Msk);
000006  6ac3              LDR      r3,[r0,#0x2c]
000008  24cf              MOVS     r4,#0xcf
00000a  43a3              BICS     r3,r3,r4
00000c  62c3              STR      r3,[r0,#0x2c]
;;;462        uart->ALTCTL |= (u32Mode | (u32BreakLength << UART_ALTCTL_BRKFL_Pos));
00000e  6ac3              LDR      r3,[r0,#0x2c]
000010  460c              MOV      r4,r1
000012  4314              ORRS     r4,r4,r2
000014  4323              ORRS     r3,r3,r4
000016  62c3              STR      r3,[r0,#0x2c]
;;;463    }
000018  bd10              POP      {r4,pc}
;;;464    
                          ENDP


                          AREA ||i.UART_SelectRS485Mode||, CODE, READONLY, ALIGN=2

                  UART_SelectRS485Mode PROC
;;;430     */
;;;431    void UART_SelectRS485Mode(UART_T* uart, uint32_t u32Mode, uint32_t u32Addr)
000000  b510              PUSH     {r4,lr}
;;;432    {
;;;433        /* Select UART RS485 function mode */
;;;434        uart->FUNCSEL = UART_FUNCSEL_RS485;
000002  2303              MOVS     r3,#3
000004  6303              STR      r3,[r0,#0x30]
;;;435    
;;;436        /* Set RS585 configuration */
;;;437        uart->ALTCTL &= ~(UART_ALTCTL_RS485NMM_Msk | UART_ALTCTL_RS485AUD_Msk | UART_ALTCTL_RS485AAD_Msk | UART_ALTCTL_ADDRMV_Msk);
000006  6ac3              LDR      r3,[r0,#0x2c]
000008  4c04              LDR      r4,|L14.28|
00000a  4023              ANDS     r3,r3,r4
00000c  62c3              STR      r3,[r0,#0x2c]
;;;438        uart->ALTCTL |= (u32Mode | (u32Addr << UART_ALTCTL_ADDRMV_Pos));
00000e  6ac3              LDR      r3,[r0,#0x2c]
000010  0614              LSLS     r4,r2,#24
000012  430c              ORRS     r4,r4,r1
000014  4323              ORRS     r3,r3,r4
000016  62c3              STR      r3,[r0,#0x2c]
;;;439    }
000018  bd10              POP      {r4,pc}
;;;440    
                          ENDP

00001a  0000              DCW      0x0000
                  |L14.28|
                          DCD      0x00fff8ff

                          AREA ||i.UART_SetLine_Config||, CODE, READONLY, ALIGN=2

                  UART_SetLine_Config PROC
;;;308     */
;;;309    void UART_SetLine_Config(UART_T* uart, uint32_t u32baudrate, uint32_t u32data_width, uint32_t u32parity, uint32_t  u32stop_bits)
000000  b5ff              PUSH     {r0-r7,lr}
;;;310    {
000002  b087              SUB      sp,sp,#0x1c
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
000008  4617              MOV      r7,r2
;;;311        uint8_t u8UartClkSrcSel, u8UartClkDivNum;
;;;312        uint32_t u32ClkTbl[4] = {__HXT, 0, __LXT, __HIRC};
00000a  4828              LDR      r0,|L15.172|
00000c  4601              MOV      r1,r0
00000e  c90e              LDM      r1,{r1-r3}
000010  68c0              LDR      r0,[r0,#0xc]  ; <Data2>
000012  ae02              ADD      r6,sp,#8
000014  c60e              STM      r6!,{r1-r3}
000016  9005              STR      r0,[sp,#0x14]
;;;313        uint32_t u32Baud_Div = 0;
000018  2000              MOVS     r0,#0
00001a  9001              STR      r0,[sp,#4]
;;;314    
;;;315        /* Get UART clock source selection */
;;;316        u8UartClkSrcSel = (CLK->CLKSEL1 & CLK_CLKSEL1_UARTSEL_Msk) >> CLK_CLKSEL1_UARTSEL_Pos;
00001c  4824              LDR      r0,|L15.176|
00001e  6940              LDR      r0,[r0,#0x14]
000020  2103              MOVS     r1,#3
000022  0609              LSLS     r1,r1,#24
000024  4008              ANDS     r0,r0,r1
000026  0e06              LSRS     r6,r0,#24
;;;317    
;;;318        /* Get UART clock divider number */
;;;319        u8UartClkDivNum = (CLK->CLKDIV0 & CLK_CLKDIV0_UARTDIV_Msk) >> CLK_CLKDIV0_UARTDIV_Pos;
000028  4821              LDR      r0,|L15.176|
00002a  6980              LDR      r0,[r0,#0x18]
00002c  210f              MOVS     r1,#0xf
00002e  0209              LSLS     r1,r1,#8
000030  4008              ANDS     r0,r0,r1
000032  0a00              LSRS     r0,r0,#8
000034  9006              STR      r0,[sp,#0x18]
;;;320    
;;;321        /* Get PLL clock frequency if UART clock source selection is PLL */
;;;322        if(u8UartClkSrcSel == 1)
000036  2e01              CMP      r6,#1
000038  d104              BNE      |L15.68|
;;;323            u32ClkTbl[u8UartClkSrcSel] = CLK_GetPLLClockFreq();
00003a  f7fffffe          BL       CLK_GetPLLClockFreq
00003e  00b1              LSLS     r1,r6,#2
000040  aa02              ADD      r2,sp,#8
000042  5050              STR      r0,[r2,r1]
                  |L15.68|
;;;324    
;;;325        /* Set UART baud rate */
;;;326        if(u32baudrate != 0)
000044  2d00              CMP      r5,#0
000046  d028              BEQ      |L15.154|
;;;327        {
;;;328            u32Baud_Div = UART_BAUD_MODE2_DIVIDER((u32ClkTbl[u8UartClkSrcSel]) / (u8UartClkDivNum + 1), u32baudrate);
000048  00b1              LSLS     r1,r6,#2
00004a  aa02              ADD      r2,sp,#8
00004c  5850              LDR      r0,[r2,r1]
00004e  9906              LDR      r1,[sp,#0x18]
000050  1c49              ADDS     r1,r1,#1
000052  f7fffffe          BL       __aeabi_uidivmod
000056  0869              LSRS     r1,r5,#1
000058  1840              ADDS     r0,r0,r1
00005a  4629              MOV      r1,r5
00005c  9000              STR      r0,[sp,#0]
00005e  f7fffffe          BL       __aeabi_uidivmod
000062  1e80              SUBS     r0,r0,#2
000064  9001              STR      r0,[sp,#4]
;;;329    
;;;330            if(u32Baud_Div > 0xFFFF)
000066  4913              LDR      r1,|L15.180|
000068  9801              LDR      r0,[sp,#4]
00006a  4288              CMP      r0,r1
00006c  d910              BLS      |L15.144|
;;;331                uart->BAUD = (UART_BAUD_MODE0 | UART_BAUD_MODE0_DIVIDER((u32ClkTbl[u8UartClkSrcSel]) / (u8UartClkDivNum + 1), u32baudrate));
00006e  00b1              LSLS     r1,r6,#2
000070  aa02              ADD      r2,sp,#8
000072  5850              LDR      r0,[r2,r1]
000074  9906              LDR      r1,[sp,#0x18]
000076  1c49              ADDS     r1,r1,#1
000078  f7fffffe          BL       __aeabi_uidivmod
00007c  00e9              LSLS     r1,r5,#3
00007e  1840              ADDS     r0,r0,r1
000080  4629              MOV      r1,r5
000082  9000              STR      r0,[sp,#0]
000084  f7fffffe          BL       __aeabi_uidivmod
000088  0900              LSRS     r0,r0,#4
00008a  1e80              SUBS     r0,r0,#2
00008c  6260              STR      r0,[r4,#0x24]
00008e  e004              B        |L15.154|
                  |L15.144|
;;;332            else
;;;333                uart->BAUD = (UART_BAUD_MODE2 | u32Baud_Div);
000090  2103              MOVS     r1,#3
000092  0709              LSLS     r1,r1,#28
000094  9801              LDR      r0,[sp,#4]
000096  4308              ORRS     r0,r0,r1
000098  6260              STR      r0,[r4,#0x24]
                  |L15.154|
;;;334        }
;;;335    
;;;336        /* Set UART line configuration */
;;;337        uart->LINE = u32data_width | u32parity | u32stop_bits;
00009a  4638              MOV      r0,r7
00009c  990a              LDR      r1,[sp,#0x28]
00009e  4308              ORRS     r0,r0,r1
0000a0  9910              LDR      r1,[sp,#0x40]
0000a2  4308              ORRS     r0,r0,r1
0000a4  60e0              STR      r0,[r4,#0xc]
;;;338    }
0000a6  b00b              ADD      sp,sp,#0x2c
0000a8  bdf0              POP      {r4-r7,pc}
;;;339    
                          ENDP

0000aa  0000              DCW      0x0000
                  |L15.172|
                          DCD      ||.constdata||+0x10
                  |L15.176|
                          DCD      0x50000200
                  |L15.180|
                          DCD      0x0000ffff

                          AREA ||i.UART_SetTimeoutCnt||, CODE, READONLY, ALIGN=1

                  UART_SetTimeoutCnt PROC
;;;350     */
;;;351    void UART_SetTimeoutCnt(UART_T* uart, uint32_t u32TOC)
000000  6a02              LDR      r2,[r0,#0x20]
;;;352    {
;;;353        /* Set time-out interrupt comparator */
;;;354        uart->TOUT = (uart->TOUT & ~UART_TOUT_TOIC_Msk) | (u32TOC);
000002  0a12              LSRS     r2,r2,#8
000004  0212              LSLS     r2,r2,#8
000006  430a              ORRS     r2,r2,r1
000008  6202              STR      r2,[r0,#0x20]
;;;355    
;;;356        /* Set time-out counter enable */
;;;357        uart->INTEN |= UART_INTEN_TOCNTEN_Msk;
00000a  6842              LDR      r2,[r0,#4]
00000c  2301              MOVS     r3,#1
00000e  02db              LSLS     r3,r3,#11
000010  431a              ORRS     r2,r2,r3
000012  6042              STR      r2,[r0,#4]
;;;358    }
000014  4770              BX       lr
;;;359    
                          ENDP


                          AREA ||i.UART_Write||, CODE, READONLY, ALIGN=1

                  UART_Write PROC
;;;476     */
;;;477    uint32_t UART_Write(UART_T* uart, uint8_t *pu8TxBuf, uint32_t u32WriteBytes)
000000  b570              PUSH     {r4-r6,lr}
;;;478    {
000002  4603              MOV      r3,r0
000004  460c              MOV      r4,r1
;;;479        uint32_t  u32Count, u32delayno;
;;;480    
;;;481        for(u32Count = 0; u32Count != u32WriteBytes; u32Count++)
000006  2100              MOVS     r1,#0
000008  e011              B        |L17.46|
                  |L17.10|
;;;482        {
;;;483            u32delayno = 0;
00000a  2500              MOVS     r5,#0
;;;484            while((uart->FIFOSTS & UART_FIFOSTS_TXEMPTYF_Msk) == 0)   /* Wait Tx empty and Time-out manner */
00000c  e006              B        |L17.28|
                  |L17.14|
;;;485            {
;;;486                u32delayno++;
00000e  1c6d              ADDS     r5,r5,#1
;;;487                if(u32delayno >= 0x40000000)
000010  2001              MOVS     r0,#1
000012  0780              LSLS     r0,r0,#30
000014  4285              CMP      r5,r0
000016  d301              BCC      |L17.28|
;;;488                    return FALSE;
000018  2000              MOVS     r0,#0
                  |L17.26|
;;;489            }
;;;490            uart->DAT = pu8TxBuf[u32Count];    /* Send UART Data from buffer */
;;;491        }
;;;492    
;;;493        return u32Count;
;;;494    
;;;495    }
00001a  bd70              POP      {r4-r6,pc}
                  |L17.28|
00001c  6998              LDR      r0,[r3,#0x18]         ;484
00001e  2601              MOVS     r6,#1                 ;484
000020  0736              LSLS     r6,r6,#28             ;484
000022  4030              ANDS     r0,r0,r6              ;484
000024  2800              CMP      r0,#0                 ;484
000026  d0f2              BEQ      |L17.14|
000028  5c60              LDRB     r0,[r4,r1]            ;490
00002a  6018              STR      r0,[r3,#0]            ;490
00002c  1c49              ADDS     r1,r1,#1              ;481
                  |L17.46|
00002e  4291              CMP      r1,r2                 ;481
000030  d1eb              BNE      |L17.10|
000032  4608              MOV      r0,r1                 ;493
000034  e7f1              B        |L17.26|
;;;496    
                          ENDP


                          AREA ||.constdata||, DATA, READONLY, ALIGN=2

                          DCD      0x00a8c000
                          DCD      0x00000000
                          DCD      0x00008000
                          DCD      0x01518000
                          DCD      0x00a8c000
                          DCD      0x00000000
                          DCD      0x00008000
                          DCD      0x01518000
                          DCD      0x00a8c000
                          DCD      0x00000000
                          DCD      0x00008000
                          DCD      0x01518000

;*** Start embedded assembler ***

#line 1 "..\\..\\..\\NUC126_Series_BSP_CMSIS_V3.00.005\\Library\\StdDriver\\src\\uart.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___6_uart_c_f12f5b44____REV16|
#line 388 "..\\..\\..\\NUC126_Series_BSP_CMSIS_V3.00.005\\Library\\CMSIS\\Include\\cmsis_armcc.h"
|__asm___6_uart_c_f12f5b44____REV16| PROC
#line 389

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___6_uart_c_f12f5b44____REVSH|
#line 402
|__asm___6_uart_c_f12f5b44____REVSH| PROC
#line 403

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
