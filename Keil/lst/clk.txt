; generated by Component: ARM Compiler 5.05 update 1 (build 106) Tool: ArmCC [4d0efa]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\obj\clk.o --asm_dir=.\lst\ --list_dir=.\lst\ --depend=.\obj\clk.d --cpu=Cortex-M0 --apcs=interwork -O0 --diag_suppress=9931 -I..\..\..\Library\CMSIS\Include -I..\..\..\Library\Device\Nuvoton\NUC126\Include -I..\..\..\Library\StdDriver\inc -I..\..\..\NUC126_Series_BSP_CMSIS_V3.00.005\Library\StdDriver\inc -I..\..\..\NUC126_Series_BSP_CMSIS_V3.00.005\Library\Device\Nuvoton\NUC126\Include -I..\..\..\NUC126_Series_BSP_CMSIS_V3.00.005\Library\CMSIS\Include -IC:\Keil_v5\ARM\RV31\INC -IC:\Keil_v5\ARM\CMSIS\Include -D__MICROLIB -D__UVISION_VERSION=514 --omf_browse=.\obj\clk.crf ..\..\..\NUC126_Series_BSP_CMSIS_V3.00.005\Library\StdDriver\src\clk.c]
                          THUMB

                          AREA ||i.CLK_DisableCKO||, CODE, READONLY, ALIGN=2

                  CLK_DisableCKO PROC
;;;32       */
;;;33     void CLK_DisableCKO(void)
000000  4803              LDR      r0,|L1.16|
;;;34     {
;;;35         /* Disable CKO clock source */
;;;36         CLK->APBCLK0 &= (~CLK_APBCLK0_CLKOCKEN_Msk);
000002  6880              LDR      r0,[r0,#8]
000004  2140              MOVS     r1,#0x40
000006  4388              BICS     r0,r0,r1
000008  4901              LDR      r1,|L1.16|
00000a  6088              STR      r0,[r1,#8]
;;;37     }
00000c  4770              BX       lr
;;;38     
                          ENDP

00000e  0000              DCW      0x0000
                  |L1.16|
                          DCD      0x50000200

                          AREA ||i.CLK_DisableModuleClock||, CODE, READONLY, ALIGN=2

                  CLK_DisableModuleClock PROC
;;;533      */
;;;534    void CLK_DisableModuleClock(uint32_t u32ModuleIdx)
000000  b50e              PUSH     {r1-r3,lr}
;;;535    {
;;;536        uint32_t u32ClkTbl[3] = {0x0, 0x4, 0x2C};
000002  4b0d              LDR      r3,|L2.56|
000004  681a              LDR      r2,[r3,#0]  ; <Data4>
000006  6859              LDR      r1,[r3,#4]  ; <Data4>
000008  689b              LDR      r3,[r3,#8]  ; <Data4>
00000a  9302              STR      r3,[sp,#8]
00000c  9200              STR      r2,[sp,#0]
00000e  9101              STR      r1,[sp,#4]
;;;537    
;;;538        *(volatile uint32_t *)((uint32_t)&CLK->AHBCLK + (u32ClkTbl[MODULE_APBCLK(u32ModuleIdx)]))  &= ~(1 << MODULE_IP_EN_Pos(u32ModuleIdx));
000010  0f81              LSRS     r1,r0,#30
000012  0089              LSLS     r1,r1,#2
000014  466a              MOV      r2,sp
000016  5851              LDR      r1,[r2,r1]
000018  4a08              LDR      r2,|L2.60|
00001a  1889              ADDS     r1,r1,r2
00001c  6849              LDR      r1,[r1,#4]
00001e  06c3              LSLS     r3,r0,#27
000020  0edb              LSRS     r3,r3,#27
000022  2201              MOVS     r2,#1
000024  409a              LSLS     r2,r2,r3
000026  4391              BICS     r1,r1,r2
000028  0f82              LSRS     r2,r0,#30
00002a  0092              LSLS     r2,r2,#2
00002c  466b              MOV      r3,sp
00002e  589a              LDR      r2,[r3,r2]
000030  4b02              LDR      r3,|L2.60|
000032  18d2              ADDS     r2,r2,r3
000034  6051              STR      r1,[r2,#4]
;;;539    }
000036  bd0e              POP      {r1-r3,pc}
;;;540    
                          ENDP

                  |L2.56|
                          DCD      ||.constdata||+0x24
                  |L2.60|
                          DCD      0x50000200

                          AREA ||i.CLK_DisablePLL||, CODE, READONLY, ALIGN=2

                  CLK_DisablePLL PROC
;;;675      */
;;;676    void CLK_DisablePLL(void)
000000  4803              LDR      r0,|L3.16|
;;;677    {
;;;678        CLK->PLLCTL |= CLK_PLLCTL_PD_Msk;
000002  6a00              LDR      r0,[r0,#0x20]
000004  2101              MOVS     r1,#1
000006  0409              LSLS     r1,r1,#16
000008  4308              ORRS     r0,r0,r1
00000a  4901              LDR      r1,|L3.16|
00000c  6208              STR      r0,[r1,#0x20]
;;;679    }
00000e  4770              BX       lr
;;;680    
                          ENDP

                  |L3.16|
                          DCD      0x50000200

                          AREA ||i.CLK_DisableSysTick||, CODE, READONLY, ALIGN=2

                  CLK_DisableSysTick PROC
;;;747      */
;;;748    void CLK_DisableSysTick(void)
000000  2000              MOVS     r0,#0
;;;749    {
;;;750        /* Set System Tick counter disabled */
;;;751        SysTick->CTRL = 0;
000002  4901              LDR      r1,|L4.8|
000004  6108              STR      r0,[r1,#0x10]
;;;752    }
000006  4770              BX       lr
;;;753    
                          ENDP

                  |L4.8|
                          DCD      0xe000e000

                          AREA ||i.CLK_DisableXtalRC||, CODE, READONLY, ALIGN=2

                  CLK_DisableXtalRC PROC
;;;441      */
;;;442    void CLK_DisableXtalRC(uint32_t u32ClkMask)
000000  4902              LDR      r1,|L5.12|
;;;443    {
;;;444        CLK->PWRCTL &= ~u32ClkMask;
000002  6809              LDR      r1,[r1,#0]
000004  4381              BICS     r1,r1,r0
000006  4a01              LDR      r2,|L5.12|
000008  6011              STR      r1,[r2,#0]
;;;445    }
00000a  4770              BX       lr
;;;446    
                          ENDP

                  |L5.12|
                          DCD      0x50000200

                          AREA ||i.CLK_EnableCKO||, CODE, READONLY, ALIGN=2

                  CLK_EnableCKO PROC
;;;58       */
;;;59     void CLK_EnableCKO(uint32_t u32ClkSrc, uint32_t u32ClkDiv, uint32_t u32ClkDivBy1En)
000000  b510              PUSH     {r4,lr}
;;;60     {
;;;61         /* CKO = clock source / 2^(u32ClkDiv + 1) */
;;;62         CLK->CLKOCTL = CLK_CLKOCTL_CLKOEN_Msk | u32ClkDiv | (u32ClkDivBy1En << CLK_CLKOCTL_DIV1EN_Pos);
000002  2310              MOVS     r3,#0x10
000004  430b              ORRS     r3,r3,r1
000006  0154              LSLS     r4,r2,#5
000008  4323              ORRS     r3,r3,r4
00000a  4c08              LDR      r4,|L6.44|
00000c  6263              STR      r3,[r4,#0x24]
;;;63     
;;;64         /* Enable CKO clock source */
;;;65         CLK->APBCLK0 |= CLK_APBCLK0_CLKOCKEN_Msk;
00000e  4623              MOV      r3,r4
000010  689b              LDR      r3,[r3,#8]
000012  2440              MOVS     r4,#0x40
000014  4323              ORRS     r3,r3,r4
000016  4c05              LDR      r4,|L6.44|
000018  60a3              STR      r3,[r4,#8]
;;;66     
;;;67         /* Select CKO clock source */
;;;68         CLK->CLKSEL2 = (CLK->CLKSEL2 & (~CLK_CLKSEL2_CLKOSEL_Msk)) | (u32ClkSrc);
00001a  4623              MOV      r3,r4
00001c  69db              LDR      r3,[r3,#0x1c]
00001e  241c              MOVS     r4,#0x1c
000020  43a3              BICS     r3,r3,r4
000022  4303              ORRS     r3,r3,r0
000024  4c01              LDR      r4,|L6.44|
000026  61e3              STR      r3,[r4,#0x1c]
;;;69     
;;;70     }
000028  bd10              POP      {r4,pc}
;;;71     
                          ENDP

00002a  0000              DCW      0x0000
                  |L6.44|
                          DCD      0x50000200

                          AREA ||i.CLK_EnableModuleClock||, CODE, READONLY, ALIGN=2

                  CLK_EnableModuleClock PROC
;;;486      */
;;;487    void CLK_EnableModuleClock(uint32_t u32ModuleIdx)
000000  b50e              PUSH     {r1-r3,lr}
;;;488    {
;;;489        uint32_t u32ClkTbl[3] = {0x0, 0x4, 0x2C};
000002  4b0d              LDR      r3,|L7.56|
000004  681a              LDR      r2,[r3,#0]  ; <Data3>
000006  6859              LDR      r1,[r3,#4]  ; <Data3>
000008  689b              LDR      r3,[r3,#8]  ; <Data3>
00000a  9302              STR      r3,[sp,#8]
00000c  9200              STR      r2,[sp,#0]
00000e  9101              STR      r1,[sp,#4]
;;;490    
;;;491        *(volatile uint32_t *)((uint32_t)&CLK->AHBCLK + (u32ClkTbl[MODULE_APBCLK(u32ModuleIdx)]))  |= 1 << MODULE_IP_EN_Pos(u32ModuleIdx);
000010  0f81              LSRS     r1,r0,#30
000012  0089              LSLS     r1,r1,#2
000014  466a              MOV      r2,sp
000016  5851              LDR      r1,[r2,r1]
000018  4a08              LDR      r2,|L7.60|
00001a  1889              ADDS     r1,r1,r2
00001c  6849              LDR      r1,[r1,#4]
00001e  06c3              LSLS     r3,r0,#27
000020  0edb              LSRS     r3,r3,#27
000022  2201              MOVS     r2,#1
000024  409a              LSLS     r2,r2,r3
000026  4311              ORRS     r1,r1,r2
000028  0f82              LSRS     r2,r0,#30
00002a  0092              LSLS     r2,r2,#2
00002c  466b              MOV      r3,sp
00002e  589a              LDR      r2,[r3,r2]
000030  4b02              LDR      r3,|L7.60|
000032  18d2              ADDS     r2,r2,r3
000034  6051              STR      r1,[r2,#4]
;;;492    }
000036  bd0e              POP      {r1-r3,pc}
;;;493    
                          ENDP

                  |L7.56|
                          DCD      ||.constdata||+0x18
                  |L7.60|
                          DCD      0x50000200

                          AREA ||i.CLK_EnablePLL||, CODE, READONLY, ALIGN=2

                  CLK_EnablePLL PROC
;;;551      */
;;;552    uint32_t CLK_EnablePLL(uint32_t u32PllClkSrc, uint32_t u32PllFreq)
000000  b5f3              PUSH     {r0,r1,r4-r7,lr}
;;;553    {
000002  b089              SUB      sp,sp,#0x24
000004  460c              MOV      r4,r1
;;;554        uint32_t u32PllSrcClk, u32NR, u32NF, u32NO, u32CLK_SRC;
;;;555        uint32_t u32Tmp, u32Tmp2, u32Tmp3, u32Min, u32MinNF, u32MinNR;
;;;556    
;;;557        /* Disable PLL first to avoid unstable when setting PLL */
;;;558        CLK_DisablePLL();
000006  f7fffffe          BL       CLK_DisablePLL
;;;559    
;;;560        /* PLL source clock is from HXT */
;;;561        if(u32PllClkSrc == CLK_PLLCTL_PLLSRC_HXT)
00000a  9809              LDR      r0,[sp,#0x24]
00000c  2800              CMP      r0,#0
00000e  d10e              BNE      |L8.46|
;;;562        {
;;;563            /* Enable HXT clock */
;;;564            CLK->PWRCTL |= CLK_PWRCTL_HXTEN_Msk;
000010  4850              LDR      r0,|L8.340|
000012  6800              LDR      r0,[r0,#0]
000014  2101              MOVS     r1,#1
000016  4308              ORRS     r0,r0,r1
000018  494e              LDR      r1,|L8.340|
00001a  6008              STR      r0,[r1,#0]
;;;565    
;;;566            /* Wait for HXT clock ready */
;;;567            CLK_WaitClockReady(CLK_STATUS_HXTSTB_Msk);
00001c  2001              MOVS     r0,#1
00001e  f7fffffe          BL       CLK_WaitClockReady
;;;568    
;;;569            /* Select PLL source clock from HXT */
;;;570            u32CLK_SRC = CLK_PLLCTL_PLLSRC_HXT;
000022  2000              MOVS     r0,#0
000024  9006              STR      r0,[sp,#0x18]
;;;571            u32PllSrcClk = __HXT;
000026  484c              LDR      r0,|L8.344|
000028  9008              STR      r0,[sp,#0x20]
;;;572    
;;;573            /* u32NR start from 2 */
;;;574            u32NR = 2;
00002a  2502              MOVS     r5,#2
00002c  e00e              B        |L8.76|
                  |L8.46|
;;;575        }
;;;576    
;;;577        /* PLL source clock is from HIRC */
;;;578        else
;;;579        {
;;;580            /* Enable HIRC clock */
;;;581            CLK->PWRCTL |= CLK_PWRCTL_HIRCEN_Msk;
00002e  4849              LDR      r0,|L8.340|
000030  6800              LDR      r0,[r0,#0]
000032  2104              MOVS     r1,#4
000034  4308              ORRS     r0,r0,r1
000036  4947              LDR      r1,|L8.340|
000038  6008              STR      r0,[r1,#0]
;;;582    
;;;583            /* Wait for HIRC clock ready */
;;;584            CLK_WaitClockReady(CLK_STATUS_HIRCSTB_Msk);
00003a  2010              MOVS     r0,#0x10
00003c  f7fffffe          BL       CLK_WaitClockReady
;;;585    
;;;586            /* Select PLL source clock from HIRC */
;;;587            u32CLK_SRC = CLK_PLLCTL_PLLSRC_HIRC;
000040  2001              MOVS     r0,#1
000042  04c0              LSLS     r0,r0,#19
000044  9006              STR      r0,[sp,#0x18]
;;;588            u32PllSrcClk = __HIRC;
000046  4845              LDR      r0,|L8.348|
000048  9008              STR      r0,[sp,#0x20]
;;;589    
;;;590            /* u32NR start from 4 when FIN = 22.1184MHz to avoid calculation overflow */
;;;591            u32NR = 4;
00004a  2504              MOVS     r5,#4
                  |L8.76|
;;;592        }
;;;593    
;;;594        /* Select "NO" according to request frequency */
;;;595        if((u32PllFreq <= FREQ_200MHZ) && (u32PllFreq > FREQ_100MHZ))
00004c  4844              LDR      r0,|L8.352|
00004e  4284              CMP      r4,r0
000050  d804              BHI      |L8.92|
000052  1040              ASRS     r0,r0,#1
000054  4284              CMP      r4,r0
000056  d901              BLS      |L8.92|
;;;596        {
;;;597            u32NO = 0;
000058  2700              MOVS     r7,#0
00005a  e012              B        |L8.130|
                  |L8.92|
;;;598        }
;;;599        else if((u32PllFreq <= FREQ_100MHZ) && (u32PllFreq > FREQ_50MHZ))
00005c  4841              LDR      r0,|L8.356|
00005e  4284              CMP      r4,r0
000060  d805              BHI      |L8.110|
000062  1040              ASRS     r0,r0,#1
000064  4284              CMP      r4,r0
000066  d902              BLS      |L8.110|
;;;600        {
;;;601            u32NO = 1;
000068  2701              MOVS     r7,#1
;;;602            u32PllFreq = u32PllFreq << 1;
00006a  0064              LSLS     r4,r4,#1
00006c  e009              B        |L8.130|
                  |L8.110|
;;;603        }
;;;604        else if((u32PllFreq <= FREQ_50MHZ) && (u32PllFreq >= FREQ_25MHZ))
00006e  483e              LDR      r0,|L8.360|
000070  4284              CMP      r4,r0
000072  d805              BHI      |L8.128|
000074  1040              ASRS     r0,r0,#1
000076  4284              CMP      r4,r0
000078  d302              BCC      |L8.128|
;;;605        {
;;;606            u32NO = 3;
00007a  2703              MOVS     r7,#3
;;;607            u32PllFreq = u32PllFreq << 2;
00007c  00a4              LSLS     r4,r4,#2
00007e  e000              B        |L8.130|
                  |L8.128|
;;;608        }
;;;609        else
;;;610        {
;;;611            /* Wrong frequency request. Just return default setting. */
;;;612            goto lexit;
000080  e057              B        |L8.306|
                  |L8.130|
;;;613        }
;;;614    
;;;615        /* Find best solution */
;;;616        u32Min = (uint32_t) - 1;
000082  2000              MOVS     r0,#0
000084  43c0              MVNS     r0,r0
000086  9003              STR      r0,[sp,#0xc]
;;;617        u32MinNR = 0;
000088  2000              MOVS     r0,#0
00008a  9001              STR      r0,[sp,#4]
;;;618        u32MinNF = 0;
00008c  9002              STR      r0,[sp,#8]
;;;619        for(; u32NR <= 33; u32NR++)
00008e  e034              B        |L8.250|
                  |L8.144|
;;;620        {
;;;621            u32Tmp = u32PllSrcClk / u32NR;
000090  4629              MOV      r1,r5
000092  9808              LDR      r0,[sp,#0x20]
000094  f7fffffe          BL       __aeabi_uidivmod
000098  9005              STR      r0,[sp,#0x14]
;;;622            if((u32Tmp > 1600000) && (u32Tmp < 16000000))
00009a  4934              LDR      r1,|L8.364|
00009c  9805              LDR      r0,[sp,#0x14]
00009e  4288              CMP      r0,r1
0000a0  d92a              BLS      |L8.248|
0000a2  4933              LDR      r1,|L8.368|
0000a4  9805              LDR      r0,[sp,#0x14]
0000a6  4288              CMP      r0,r1
0000a8  d226              BCS      |L8.248|
;;;623            {
;;;624                for(u32NF = 2; u32NF <= 513; u32NF++)
0000aa  2002              MOVS     r0,#2
0000ac  9007              STR      r0,[sp,#0x1c]
0000ae  e01e              B        |L8.238|
                  |L8.176|
;;;625                {
;;;626                    u32Tmp2 = u32Tmp * u32NF;
0000b0  9e05              LDR      r6,[sp,#0x14]
0000b2  9907              LDR      r1,[sp,#0x1c]
0000b4  434e              MULS     r6,r1,r6
;;;627                    if((u32Tmp2 >= 100000000) && (u32Tmp2 <= 200000000))
0000b6  482b              LDR      r0,|L8.356|
0000b8  4286              CMP      r6,r0
0000ba  d315              BCC      |L8.232|
0000bc  0040              LSLS     r0,r0,#1
0000be  4286              CMP      r6,r0
0000c0  d812              BHI      |L8.232|
;;;628                    {
;;;629                        u32Tmp3 = (u32Tmp2 > u32PllFreq) ? u32Tmp2 - u32PllFreq : u32PllFreq - u32Tmp2;
0000c2  42a6              CMP      r6,r4
0000c4  d901              BLS      |L8.202|
0000c6  1b30              SUBS     r0,r6,r4
0000c8  e000              B        |L8.204|
                  |L8.202|
0000ca  1ba0              SUBS     r0,r4,r6
                  |L8.204|
0000cc  9004              STR      r0,[sp,#0x10]
;;;630                        if(u32Tmp3 < u32Min)
0000ce  9903              LDR      r1,[sp,#0xc]
0000d0  9804              LDR      r0,[sp,#0x10]
0000d2  4288              CMP      r0,r1
0000d4  d208              BCS      |L8.232|
;;;631                        {
;;;632                            u32Min = u32Tmp3;
0000d6  9804              LDR      r0,[sp,#0x10]
0000d8  9003              STR      r0,[sp,#0xc]
;;;633                            u32MinNR = u32NR;
0000da  9501              STR      r5,[sp,#4]
;;;634                            u32MinNF = u32NF;
0000dc  9807              LDR      r0,[sp,#0x1c]
0000de  9002              STR      r0,[sp,#8]
;;;635    
;;;636                            /* Break when get good results */
;;;637                            if(u32Min == 0)
0000e0  9803              LDR      r0,[sp,#0xc]
0000e2  2800              CMP      r0,#0
0000e4  d100              BNE      |L8.232|
;;;638                                break;
0000e6  e006              B        |L8.246|
                  |L8.232|
0000e8  9807              LDR      r0,[sp,#0x1c]         ;624
0000ea  1c40              ADDS     r0,r0,#1              ;624
0000ec  9007              STR      r0,[sp,#0x1c]         ;624
                  |L8.238|
0000ee  4921              LDR      r1,|L8.372|
0000f0  9807              LDR      r0,[sp,#0x1c]         ;624
0000f2  4288              CMP      r0,r1                 ;624
0000f4  d9dc              BLS      |L8.176|
                  |L8.246|
0000f6  bf00              NOP      
                  |L8.248|
0000f8  1c6d              ADDS     r5,r5,#1              ;619
                  |L8.250|
0000fa  2d21              CMP      r5,#0x21              ;619
0000fc  d9c8              BLS      |L8.144|
;;;639                        }
;;;640                    }
;;;641                }
;;;642            }
;;;643        }
;;;644    
;;;645        /* Enable and apply new PLL setting. */
;;;646        CLK->PLLCTL = u32CLK_SRC | (u32NO << 14) | ((u32MinNR - 2) << 9) | (u32MinNF - 2);
0000fe  03b8              LSLS     r0,r7,#14
000100  9906              LDR      r1,[sp,#0x18]
000102  4308              ORRS     r0,r0,r1
000104  9901              LDR      r1,[sp,#4]
000106  1e89              SUBS     r1,r1,#2
000108  0249              LSLS     r1,r1,#9
00010a  4308              ORRS     r0,r0,r1
00010c  9902              LDR      r1,[sp,#8]
00010e  1e89              SUBS     r1,r1,#2
000110  4308              ORRS     r0,r0,r1
000112  4910              LDR      r1,|L8.340|
000114  6208              STR      r0,[r1,#0x20]
;;;647    
;;;648        /* Wait for PLL clock stable */
;;;649        CLK_WaitClockReady(CLK_STATUS_PLLSTB_Msk);
000116  2004              MOVS     r0,#4
000118  f7fffffe          BL       CLK_WaitClockReady
;;;650    
;;;651        /* Return actual PLL output clock frequency */
;;;652        return u32PllSrcClk / ((u32NO + 1) * u32MinNR) * u32MinNF;
00011c  1c78              ADDS     r0,r7,#1
00011e  9a01              LDR      r2,[sp,#4]
000120  4350              MULS     r0,r2,r0
000122  4601              MOV      r1,r0
000124  9808              LDR      r0,[sp,#0x20]
000126  f7fffffe          BL       __aeabi_uidivmod
00012a  9902              LDR      r1,[sp,#8]
00012c  4348              MULS     r0,r1,r0
                  |L8.302|
;;;653    
;;;654    lexit:
;;;655    
;;;656        /* Apply default PLL setting and return */
;;;657        if(u32PllClkSrc == CLK_PLLCTL_PLLSRC_HXT)
;;;658            CLK->PLLCTL = CLK_PLLCTL_72MHz_HXT; /* 72MHz */
;;;659        else
;;;660            CLK->PLLCTL = CLK_PLLCTL_72MHz_HIRC; /* 71.8848MHz */
;;;661    
;;;662        /* Wait for PLL clock stable */
;;;663        CLK_WaitClockReady(CLK_STATUS_PLLSTB_Msk);
;;;664    
;;;665        return CLK_GetPLLClockFreq();
;;;666    
;;;667    }
00012e  b00b              ADD      sp,sp,#0x2c
000130  bdf0              POP      {r4-r7,pc}
                  |L8.306|
000132  9809              LDR      r0,[sp,#0x24]         ;657
000134  2800              CMP      r0,#0                 ;657
000136  d103              BNE      |L8.320|
000138  480f              LDR      r0,|L8.376|
00013a  4906              LDR      r1,|L8.340|
00013c  6208              STR      r0,[r1,#0x20]         ;658
00013e  e002              B        |L8.326|
                  |L8.320|
000140  480e              LDR      r0,|L8.380|
000142  4904              LDR      r1,|L8.340|
000144  6208              STR      r0,[r1,#0x20]         ;660
                  |L8.326|
000146  2004              MOVS     r0,#4                 ;663
000148  f7fffffe          BL       CLK_WaitClockReady
00014c  f7fffffe          BL       CLK_GetPLLClockFreq
000150  e7ed              B        |L8.302|
;;;668    
                          ENDP

000152  0000              DCW      0x0000
                  |L8.340|
                          DCD      0x50000200
                  |L8.344|
                          DCD      0x00a8c000
                  |L8.348|
                          DCD      0x01518000
                  |L8.352|
                          DCD      0x0bebc200
                  |L8.356|
                          DCD      0x05f5e100
                  |L8.360|
                          DCD      0x02faf080
                  |L8.364|
                          DCD      0x00186a00
                  |L8.368|
                          DCD      0x00f42400
                  |L8.372|
                          DCD      0x00000201
                  |L8.376|
                          DCD      0x0000442e
                  |L8.380|
                          DCD      0x00084c32

                          AREA ||i.CLK_EnableSysTick||, CODE, READONLY, ALIGN=2

                  CLK_EnableSysTick PROC
;;;720      */
;;;721    void CLK_EnableSysTick(uint32_t u32ClkSrc, uint32_t u32Count)
000000  2200              MOVS     r2,#0
;;;722    {
;;;723        /* Set System Tick counter disabled */
;;;724        SysTick->CTRL = 0;
000002  4b0f              LDR      r3,|L9.64|
000004  611a              STR      r2,[r3,#0x10]
;;;725    
;;;726        /* Set System Tick clock source */
;;;727        if(u32ClkSrc == CLK_CLKSEL0_STCLKSEL_HCLK)
000006  2804              CMP      r0,#4
000008  d106              BNE      |L9.24|
;;;728            SysTick->CTRL |= SysTick_CTRL_CLKSOURCE_Msk;
00000a  461a              MOV      r2,r3
00000c  6912              LDR      r2,[r2,#0x10]
00000e  2304              MOVS     r3,#4
000010  431a              ORRS     r2,r2,r3
000012  4b0b              LDR      r3,|L9.64|
000014  611a              STR      r2,[r3,#0x10]
000016  e006              B        |L9.38|
                  |L9.24|
;;;729        else
;;;730            CLK->CLKSEL0 = (CLK->CLKSEL0 & ~CLK_CLKSEL0_STCLKSEL_Msk) | u32ClkSrc;
000018  4a0a              LDR      r2,|L9.68|
00001a  6912              LDR      r2,[r2,#0x10]
00001c  2338              MOVS     r3,#0x38
00001e  439a              BICS     r2,r2,r3
000020  4302              ORRS     r2,r2,r0
000022  4b08              LDR      r3,|L9.68|
000024  611a              STR      r2,[r3,#0x10]
                  |L9.38|
;;;731    
;;;732        /* Set System Tick reload value */
;;;733        SysTick->LOAD = u32Count;
000026  4a06              LDR      r2,|L9.64|
000028  6151              STR      r1,[r2,#0x14]
;;;734    
;;;735        /* Clear System Tick current value and counter flag */
;;;736        SysTick->VAL = 0;
00002a  2200              MOVS     r2,#0
00002c  4b04              LDR      r3,|L9.64|
00002e  619a              STR      r2,[r3,#0x18]
;;;737    
;;;738        /* Set System Tick interrupt enabled and counter enabled */
;;;739        SysTick->CTRL |= SysTick_CTRL_TICKINT_Msk | SysTick_CTRL_ENABLE_Msk;
000030  461a              MOV      r2,r3
000032  6912              LDR      r2,[r2,#0x10]
000034  2303              MOVS     r3,#3
000036  431a              ORRS     r2,r2,r3
000038  4b01              LDR      r3,|L9.64|
00003a  611a              STR      r2,[r3,#0x10]
;;;740    }
00003c  4770              BX       lr
;;;741    
                          ENDP

00003e  0000              DCW      0x0000
                  |L9.64|
                          DCD      0xe000e000
                  |L9.68|
                          DCD      0x50000200

                          AREA ||i.CLK_EnableXtalRC||, CODE, READONLY, ALIGN=2

                  CLK_EnableXtalRC PROC
;;;424      */
;;;425    void CLK_EnableXtalRC(uint32_t u32ClkMask)
000000  4902              LDR      r1,|L10.12|
;;;426    {
;;;427        CLK->PWRCTL |= u32ClkMask;
000002  6809              LDR      r1,[r1,#0]
000004  4301              ORRS     r1,r1,r0
000006  4a01              LDR      r2,|L10.12|
000008  6011              STR      r1,[r2,#0]
;;;428    }
00000a  4770              BX       lr
;;;429    
                          ENDP

                  |L10.12|
                          DCD      0x50000200

                          AREA ||i.CLK_GetCPUFreq||, CODE, READONLY, ALIGN=2

                  CLK_GetCPUFreq PROC
;;;185      */
;;;186    uint32_t CLK_GetCPUFreq(void)
000000  b510              PUSH     {r4,lr}
;;;187    {
;;;188        SystemCoreClockUpdate();
000002  f7fffffe          BL       SystemCoreClockUpdate
;;;189        return SystemCoreClock;
000006  4801              LDR      r0,|L11.12|
000008  6800              LDR      r0,[r0,#0]  ; SystemCoreClock
;;;190    }
00000a  bd10              POP      {r4,pc}
;;;191    
                          ENDP

                  |L11.12|
                          DCD      SystemCoreClock

                          AREA ||i.CLK_GetHCLKFreq||, CODE, READONLY, ALIGN=2

                  CLK_GetHCLKFreq PROC
;;;143      */
;;;144    uint32_t CLK_GetHCLKFreq(void)
000000  b510              PUSH     {r4,lr}
;;;145    {
;;;146        SystemCoreClockUpdate();
000002  f7fffffe          BL       SystemCoreClockUpdate
;;;147        return SystemCoreClock;
000006  4801              LDR      r0,|L12.12|
000008  6800              LDR      r0,[r0,#0]  ; SystemCoreClock
;;;148    }
00000a  bd10              POP      {r4,pc}
;;;149    
                          ENDP

                  |L12.12|
                          DCD      SystemCoreClock

                          AREA ||i.CLK_GetHXTFreq||, CODE, READONLY, ALIGN=2

                  CLK_GetHXTFreq PROC
;;;115      */
;;;116    uint32_t CLK_GetHXTFreq(void)
000000  4804              LDR      r0,|L13.20|
;;;117    {
;;;118        if(CLK->PWRCTL & CLK_PWRCTL_HXTEN_Msk)
000002  6800              LDR      r0,[r0,#0]
000004  07c0              LSLS     r0,r0,#31
000006  0fc0              LSRS     r0,r0,#31
000008  2800              CMP      r0,#0
00000a  d001              BEQ      |L13.16|
;;;119            return __HXT;
00000c  4802              LDR      r0,|L13.24|
                  |L13.14|
;;;120        else
;;;121            return 0;
;;;122    }
00000e  4770              BX       lr
                  |L13.16|
000010  2000              MOVS     r0,#0                 ;121
000012  e7fc              B        |L13.14|
;;;123    
                          ENDP

                  |L13.20|
                          DCD      0x50000200
                  |L13.24|
                          DCD      0x00a8c000

                          AREA ||i.CLK_GetLXTFreq||, CODE, READONLY, ALIGN=2

                  CLK_GetLXTFreq PROC
;;;129      */
;;;130    uint32_t CLK_GetLXTFreq(void)
000000  4804              LDR      r0,|L14.20|
;;;131    {
;;;132        if(CLK->PWRCTL & CLK_PWRCTL_LXTEN_Msk)
000002  6800              LDR      r0,[r0,#0]
000004  2102              MOVS     r1,#2
000006  4008              ANDS     r0,r0,r1
000008  2800              CMP      r0,#0
00000a  d001              BEQ      |L14.16|
;;;133            return __LXT;
00000c  0388              LSLS     r0,r1,#14
                  |L14.14|
;;;134        else
;;;135            return 0;
;;;136    }
00000e  4770              BX       lr
                  |L14.16|
000010  2000              MOVS     r0,#0                 ;135
000012  e7fc              B        |L14.14|
;;;137    
                          ENDP

                  |L14.20|
                          DCD      0x50000200

                          AREA ||i.CLK_GetPCLK0Freq||, CODE, READONLY, ALIGN=2

                  CLK_GetPCLK0Freq PROC
;;;155      */
;;;156    uint32_t CLK_GetPCLK0Freq(void)
000000  b510              PUSH     {r4,lr}
;;;157    {
;;;158        SystemCoreClockUpdate();
000002  f7fffffe          BL       SystemCoreClockUpdate
;;;159        if(CLK->CLKSEL0 & CLK_CLKSEL0_PCLK0SEL_Msk)
000006  4806              LDR      r0,|L15.32|
000008  6900              LDR      r0,[r0,#0x10]
00000a  2140              MOVS     r1,#0x40
00000c  4008              ANDS     r0,r0,r1
00000e  2800              CMP      r0,#0
000010  d003              BEQ      |L15.26|
;;;160            return SystemCoreClock >> 1;
000012  4804              LDR      r0,|L15.36|
000014  6800              LDR      r0,[r0,#0]  ; SystemCoreClock
000016  0840              LSRS     r0,r0,#1
                  |L15.24|
;;;161        else
;;;162            return SystemCoreClock;
;;;163    }
000018  bd10              POP      {r4,pc}
                  |L15.26|
00001a  4802              LDR      r0,|L15.36|
00001c  6800              LDR      r0,[r0,#0]            ;162  ; SystemCoreClock
00001e  e7fb              B        |L15.24|
;;;164    
                          ENDP

                  |L15.32|
                          DCD      0x50000200
                  |L15.36|
                          DCD      SystemCoreClock

                          AREA ||i.CLK_GetPCLK1Freq||, CODE, READONLY, ALIGN=2

                  CLK_GetPCLK1Freq PROC
;;;170      */
;;;171    uint32_t CLK_GetPCLK1Freq(void)
000000  b510              PUSH     {r4,lr}
;;;172    {
;;;173        SystemCoreClockUpdate();
000002  f7fffffe          BL       SystemCoreClockUpdate
;;;174        if(CLK->CLKSEL0 & CLK_CLKSEL0_PCLK1SEL_Msk)
000006  4806              LDR      r0,|L16.32|
000008  6900              LDR      r0,[r0,#0x10]
00000a  2180              MOVS     r1,#0x80
00000c  4008              ANDS     r0,r0,r1
00000e  2800              CMP      r0,#0
000010  d003              BEQ      |L16.26|
;;;175            return SystemCoreClock >> 1;
000012  4804              LDR      r0,|L16.36|
000014  6800              LDR      r0,[r0,#0]  ; SystemCoreClock
000016  0840              LSRS     r0,r0,#1
                  |L16.24|
;;;176        else
;;;177            return SystemCoreClock;
;;;178    }
000018  bd10              POP      {r4,pc}
                  |L16.26|
00001a  4802              LDR      r0,|L16.36|
00001c  6800              LDR      r0,[r0,#0]            ;177  ; SystemCoreClock
00001e  e7fb              B        |L16.24|
;;;179    
                          ENDP

                  |L16.32|
                          DCD      0x50000200
                  |L16.36|
                          DCD      SystemCoreClock

                          AREA ||i.CLK_GetPLLClockFreq||, CODE, READONLY, ALIGN=2

                  CLK_GetPLLClockFreq PROC
;;;388      */
;;;389    __STATIC_INLINE uint32_t CLK_GetPLLClockFreq(void)
000000  b5fe              PUSH     {r1-r7,lr}
;;;390    {
;;;391        uint32_t u32PllFreq = 0, u32PllReg;
000002  2000              MOVS     r0,#0
000004  9002              STR      r0,[sp,#8]
;;;392        uint32_t u32FIN, u32NF, u32NR, u32NO;
;;;393        uint8_t au8NoTbl[4] = {1, 2, 2, 4};
000006  a01a              ADR      r0,|L17.112|
000008  6800              LDR      r0,[r0,#0]
00000a  9000              STR      r0,[sp,#0]
;;;394    
;;;395        u32PllReg = CLK->PLLCTL;
00000c  4819              LDR      r0,|L17.116|
00000e  6a04              LDR      r4,[r0,#0x20]
;;;396    
;;;397        if(u32PllReg & (CLK_PLLCTL_PD_Msk | CLK_PLLCTL_OE_Msk))
000010  1300              ASRS     r0,r0,#12
000012  4020              ANDS     r0,r0,r4
000014  2800              CMP      r0,#0
000016  d001              BEQ      |L17.28|
;;;398            return 0;           /* PLL is in power down mode or fix low */
000018  2000              MOVS     r0,#0
                  |L17.26|
;;;399    
;;;400        if(u32PllReg & CLK_PLLCTL_PLLSRC_HIRC)
;;;401            u32FIN = __HIRC;    /* PLL source clock from HIRC */
;;;402        else
;;;403            u32FIN = __HXT;     /* PLL source clock from HXT */
;;;404    
;;;405        if(u32PllReg & CLK_PLLCTL_BP_Msk)
;;;406            return u32FIN;      /* PLL is in bypass mode */
;;;407    
;;;408        /* PLL is output enabled in normal work mode */
;;;409        u32NO = au8NoTbl[((u32PllReg & CLK_PLLCTL_OUTDIV_Msk) >> CLK_PLLCTL_OUTDIV_Pos)];
;;;410        u32NF = ((u32PllReg & CLK_PLLCTL_FBDIV_Msk) >> CLK_PLLCTL_FBDIV_Pos) + 2;
;;;411        u32NR = ((u32PllReg & CLK_PLLCTL_INDIV_Msk) >> CLK_PLLCTL_INDIV_Pos) + 2;
;;;412    
;;;413        /* u32FIN is shifted 2 bits to avoid overflow */
;;;414        u32PllFreq = (((u32FIN >> 2) * u32NF) / (u32NR * u32NO) << 2);
;;;415    
;;;416        return u32PllFreq;
;;;417    }
00001a  bdfe              POP      {r1-r7,pc}
                  |L17.28|
00001c  2001              MOVS     r0,#1                 ;400
00001e  04c0              LSLS     r0,r0,#19             ;400
000020  4020              ANDS     r0,r0,r4              ;400
000022  2800              CMP      r0,#0                 ;400
000024  d001              BEQ      |L17.42|
000026  4d14              LDR      r5,|L17.120|
000028  e000              B        |L17.44|
                  |L17.42|
00002a  4d14              LDR      r5,|L17.124|
                  |L17.44|
00002c  2001              MOVS     r0,#1                 ;405
00002e  0440              LSLS     r0,r0,#17             ;405
000030  4020              ANDS     r0,r0,r4              ;405
000032  2800              CMP      r0,#0                 ;405
000034  d001              BEQ      |L17.58|
000036  4628              MOV      r0,r5                 ;406
000038  e7ef              B        |L17.26|
                  |L17.58|
00003a  2003              MOVS     r0,#3                 ;409
00003c  0380              LSLS     r0,r0,#14             ;409
00003e  4020              ANDS     r0,r0,r4              ;409
000040  0b80              LSRS     r0,r0,#14             ;409
000042  4669              MOV      r1,sp                 ;409
000044  5c0a              LDRB     r2,[r1,r0]            ;409
000046  9201              STR      r2,[sp,#4]            ;409
000048  05e0              LSLS     r0,r4,#23             ;410
00004a  0dc0              LSRS     r0,r0,#23             ;410
00004c  1c86              ADDS     r6,r0,#2              ;410
00004e  201f              MOVS     r0,#0x1f              ;411
000050  0240              LSLS     r0,r0,#9              ;411
000052  4020              ANDS     r0,r0,r4              ;411
000054  0a40              LSRS     r0,r0,#9              ;411
000056  1c87              ADDS     r7,r0,#2              ;411
000058  9a01              LDR      r2,[sp,#4]            ;414
00005a  437a              MULS     r2,r7,r2              ;414
00005c  4611              MOV      r1,r2                 ;414
00005e  08aa              LSRS     r2,r5,#2              ;414
000060  4372              MULS     r2,r6,r2              ;414
000062  4610              MOV      r0,r2                 ;414
000064  f7fffffe          BL       __aeabi_uidivmod
000068  0080              LSLS     r0,r0,#2              ;414
00006a  9002              STR      r0,[sp,#8]            ;414
00006c  9802              LDR      r0,[sp,#8]            ;416
00006e  e7d4              B        |L17.26|
;;;418    
                          ENDP

                  |L17.112|
000070  01020204          DCB      1,2,2,4
                  |L17.116|
                          DCD      0x50000200
                  |L17.120|
                          DCD      0x01518000
                  |L17.124|
                          DCD      0x00a8c000

                          AREA ||i.CLK_Idle||, CODE, READONLY, ALIGN=2

                  CLK_Idle PROC
;;;97       */
;;;98     void CLK_Idle(void)
000000  4806              LDR      r0,|L18.28|
;;;99     {
;;;100        /* Set the processor uses sleep as its low power mode */
;;;101        SCB->SCR &= ~SCB_SCR_SLEEPDEEP_Msk;
000002  6900              LDR      r0,[r0,#0x10]
000004  2104              MOVS     r1,#4
000006  4388              BICS     r0,r0,r1
000008  4904              LDR      r1,|L18.28|
00000a  6108              STR      r0,[r1,#0x10]
;;;102    
;;;103        /* Set chip in idle mode because of WFI command */
;;;104        CLK->PWRCTL &= ~CLK_PWRCTL_PDEN_Msk;
00000c  4804              LDR      r0,|L18.32|
00000e  6800              LDR      r0,[r0,#0]
000010  2180              MOVS     r1,#0x80
000012  4388              BICS     r0,r0,r1
000014  4902              LDR      r1,|L18.32|
000016  6008              STR      r0,[r1,#0]
;;;105    
;;;106        /* Chip enter idle mode after CPU run WFI instruction */
;;;107        __WFI();
000018  bf30              WFI      
;;;108    }
00001a  4770              BX       lr
;;;109    
                          ENDP

                  |L18.28|
                          DCD      0xe000ed00
                  |L18.32|
                          DCD      0x50000200

                          AREA ||i.CLK_PowerDown||, CODE, READONLY, ALIGN=2

                  CLK_PowerDown PROC
;;;78       */
;;;79     void CLK_PowerDown(void)
000000  4806              LDR      r0,|L19.28|
;;;80     {
;;;81         /* Set the processor uses deep sleep as its low power mode */
;;;82         SCB->SCR |= SCB_SCR_SLEEPDEEP_Msk;
000002  6900              LDR      r0,[r0,#0x10]
000004  2104              MOVS     r1,#4
000006  4308              ORRS     r0,r0,r1
000008  4904              LDR      r1,|L19.28|
00000a  6108              STR      r0,[r1,#0x10]
;;;83     
;;;84         /* Set system Power-down enabled*/
;;;85         CLK->PWRCTL |= CLK_PWRCTL_PDEN_Msk;
00000c  4804              LDR      r0,|L19.32|
00000e  6800              LDR      r0,[r0,#0]
000010  2180              MOVS     r1,#0x80
000012  4308              ORRS     r0,r0,r1
000014  4902              LDR      r1,|L19.32|
000016  6008              STR      r0,[r1,#0]
;;;86     
;;;87         /* Chip enter Power-down mode after CPU run WFI instruction */
;;;88         __WFI();
000018  bf30              WFI      
;;;89     }
00001a  4770              BX       lr
;;;90     
                          ENDP

                  |L19.28|
                          DCD      0xe000ed00
                  |L19.32|
                          DCD      0x50000200

                          AREA ||i.CLK_SetCoreClock||, CODE, READONLY, ALIGN=2

                  CLK_SetCoreClock PROC
;;;200      */
;;;201    uint32_t CLK_SetCoreClock(uint32_t u32Hclk)
000000  b570              PUSH     {r4-r6,lr}
;;;202    {
000002  4604              MOV      r4,r0
;;;203        uint32_t u32HIRCSTB;
;;;204    
;;;205        /* Read HIRC clock source stable flag */
;;;206        u32HIRCSTB = CLK->STATUS & CLK_STATUS_HIRCSTB_Msk;
000004  4822              LDR      r0,|L20.144|
000006  68c0              LDR      r0,[r0,#0xc]
000008  2110              MOVS     r1,#0x10
00000a  4008              ANDS     r0,r0,r1
00000c  4605              MOV      r5,r0
;;;207    
;;;208        /* The range of u32Hclk is 25 MHz ~ 72 MHz */
;;;209        if(u32Hclk > FREQ_72MHZ)
00000e  4821              LDR      r0,|L20.148|
000010  4284              CMP      r4,r0
000012  d900              BLS      |L20.22|
;;;210            u32Hclk = FREQ_72MHZ;
000014  4604              MOV      r4,r0
                  |L20.22|
;;;211        if(u32Hclk < FREQ_25MHZ)
000016  4820              LDR      r0,|L20.152|
000018  4284              CMP      r4,r0
00001a  d200              BCS      |L20.30|
;;;212            u32Hclk = FREQ_25MHZ;
00001c  4604              MOV      r4,r0
                  |L20.30|
;;;213    
;;;214        /* Switch HCLK clock source to HIRC clock for safe */
;;;215        CLK->PWRCTL |= CLK_PWRCTL_HIRCEN_Msk;
00001e  481c              LDR      r0,|L20.144|
000020  6800              LDR      r0,[r0,#0]
000022  2104              MOVS     r1,#4
000024  4308              ORRS     r0,r0,r1
000026  491a              LDR      r1,|L20.144|
000028  6008              STR      r0,[r1,#0]
;;;216        CLK_WaitClockReady(CLK_STATUS_HIRCSTB_Msk);
00002a  2010              MOVS     r0,#0x10
00002c  f7fffffe          BL       CLK_WaitClockReady
;;;217        CLK->CLKSEL0 |= CLK_CLKSEL0_HCLKSEL_Msk;
000030  4817              LDR      r0,|L20.144|
000032  6900              LDR      r0,[r0,#0x10]
000034  2107              MOVS     r1,#7
000036  4308              ORRS     r0,r0,r1
000038  4915              LDR      r1,|L20.144|
00003a  6108              STR      r0,[r1,#0x10]
;;;218        CLK->CLKDIV0 &= (~CLK_CLKDIV0_HCLKDIV_Msk);
00003c  4608              MOV      r0,r1
00003e  6980              LDR      r0,[r0,#0x18]
000040  0900              LSRS     r0,r0,#4
000042  0100              LSLS     r0,r0,#4
000044  6188              STR      r0,[r1,#0x18]
;;;219    
;;;220        /* Configure PLL setting if HXT clock is stable */
;;;221        if(CLK->STATUS & CLK_STATUS_HXTSTB_Msk)
000046  4608              MOV      r0,r1
000048  68c0              LDR      r0,[r0,#0xc]
00004a  07c0              LSLS     r0,r0,#31
00004c  0fc0              LSRS     r0,r0,#31
00004e  2800              CMP      r0,#0
000050  d005              BEQ      |L20.94|
;;;222            u32Hclk = CLK_EnablePLL(CLK_PLLCTL_PLLSRC_HXT, (u32Hclk << 1));
000052  0061              LSLS     r1,r4,#1
000054  2000              MOVS     r0,#0
000056  f7fffffe          BL       CLK_EnablePLL
00005a  4604              MOV      r4,r0
00005c  e00a              B        |L20.116|
                  |L20.94|
;;;223    
;;;224        /* Configure PLL setting if HXT clock is not stable */
;;;225        else
;;;226        {
;;;227            u32Hclk = CLK_EnablePLL(CLK_PLLCTL_PLLSRC_HIRC, (u32Hclk << 1));
00005e  0061              LSLS     r1,r4,#1
000060  2001              MOVS     r0,#1
000062  04c0              LSLS     r0,r0,#19
000064  f7fffffe          BL       CLK_EnablePLL
000068  4604              MOV      r4,r0
;;;228    
;;;229            /* Read HIRC clock source stable flag */
;;;230            u32HIRCSTB = CLK->STATUS & CLK_STATUS_HIRCSTB_Msk;
00006a  4809              LDR      r0,|L20.144|
00006c  68c0              LDR      r0,[r0,#0xc]
00006e  2110              MOVS     r1,#0x10
000070  4008              ANDS     r0,r0,r1
000072  4605              MOV      r5,r0
                  |L20.116|
;;;231        }
;;;232    
;;;233        /* Select HCLK clock source to PLL,
;;;234           Select HCLK clock source divider as 2
;;;235           and update system core clock
;;;236        */
;;;237        CLK_SetHCLK(CLK_CLKSEL0_HCLKSEL_PLL, CLK_CLKDIV0_HCLK(2));
000074  2101              MOVS     r1,#1
000076  2002              MOVS     r0,#2
000078  f7fffffe          BL       CLK_SetHCLK
;;;238    
;;;239        /* Disable HIRC if HIRC is disabled before setting core clock */
;;;240        if(u32HIRCSTB == 0)
00007c  2d00              CMP      r5,#0
00007e  d105              BNE      |L20.140|
;;;241            CLK->PWRCTL &= ~CLK_PWRCTL_HIRCEN_Msk;
000080  4803              LDR      r0,|L20.144|
000082  6800              LDR      r0,[r0,#0]
000084  2104              MOVS     r1,#4
000086  4388              BICS     r0,r0,r1
000088  4901              LDR      r1,|L20.144|
00008a  6008              STR      r0,[r1,#0]
                  |L20.140|
;;;242    
;;;243        /* Return actually HCLK frequency is PLL frequency divide 2 */
;;;244        return u32Hclk >> 1;
00008c  0860              LSRS     r0,r4,#1
;;;245    }
00008e  bd70              POP      {r4-r6,pc}
;;;246    
                          ENDP

                  |L20.144|
                          DCD      0x50000200
                  |L20.148|
                          DCD      0x044aa200
                  |L20.152|
                          DCD      0x017d7840

                          AREA ||i.CLK_SetHCLK||, CODE, READONLY, ALIGN=2

                  CLK_SetHCLK PROC
;;;261      */
;;;262    void CLK_SetHCLK(uint32_t u32ClkSrc, uint32_t u32ClkDiv)
000000  b570              PUSH     {r4-r6,lr}
;;;263    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;264        uint32_t u32HIRCSTB;
;;;265    
;;;266        /* Read HIRC clock source stable flag */
;;;267        u32HIRCSTB = CLK->STATUS & CLK_STATUS_HIRCSTB_Msk;
000006  4816              LDR      r0,|L21.96|
000008  68c0              LDR      r0,[r0,#0xc]
00000a  2110              MOVS     r1,#0x10
00000c  4008              ANDS     r0,r0,r1
00000e  4606              MOV      r6,r0
;;;268    
;;;269        /* Switch to HIRC for Safe. Avoid HCLK too high when applying new divider. */
;;;270        CLK->PWRCTL |= CLK_PWRCTL_HIRCEN_Msk;
000010  4813              LDR      r0,|L21.96|
000012  6800              LDR      r0,[r0,#0]
000014  2104              MOVS     r1,#4
000016  4308              ORRS     r0,r0,r1
000018  4911              LDR      r1,|L21.96|
00001a  6008              STR      r0,[r1,#0]
;;;271        CLK_WaitClockReady(CLK_STATUS_HIRCSTB_Msk);
00001c  2010              MOVS     r0,#0x10
00001e  f7fffffe          BL       CLK_WaitClockReady
;;;272        CLK->CLKSEL0 = (CLK->CLKSEL0 & (~CLK_CLKSEL0_HCLKSEL_Msk)) | CLK_CLKSEL0_HCLKSEL_HIRC;
000022  480f              LDR      r0,|L21.96|
000024  6900              LDR      r0,[r0,#0x10]
000026  08c0              LSRS     r0,r0,#3
000028  00c0              LSLS     r0,r0,#3
00002a  1dc0              ADDS     r0,r0,#7
00002c  490c              LDR      r1,|L21.96|
00002e  6108              STR      r0,[r1,#0x10]
;;;273    
;;;274        /* Apply new Divider */
;;;275        CLK->CLKDIV0 = (CLK->CLKDIV0 & (~CLK_CLKDIV0_HCLKDIV_Msk)) | u32ClkDiv;
000030  4608              MOV      r0,r1
000032  6980              LDR      r0,[r0,#0x18]
000034  0900              LSRS     r0,r0,#4
000036  0100              LSLS     r0,r0,#4
000038  4328              ORRS     r0,r0,r5
00003a  6188              STR      r0,[r1,#0x18]
;;;276    
;;;277        /* Switch HCLK to new HCLK source */
;;;278        CLK->CLKSEL0 = (CLK->CLKSEL0 & (~CLK_CLKSEL0_HCLKSEL_Msk)) | u32ClkSrc;
00003c  4608              MOV      r0,r1
00003e  6900              LDR      r0,[r0,#0x10]
000040  08c0              LSRS     r0,r0,#3
000042  00c0              LSLS     r0,r0,#3
000044  4320              ORRS     r0,r0,r4
000046  6108              STR      r0,[r1,#0x10]
;;;279    
;;;280        /* Update System Core Clock */
;;;281        SystemCoreClockUpdate();
000048  f7fffffe          BL       SystemCoreClockUpdate
;;;282    
;;;283        /* Disable HIRC if HIRC is disabled before switching HCLK source */
;;;284        if(u32HIRCSTB == 0)
00004c  2e00              CMP      r6,#0
00004e  d105              BNE      |L21.92|
;;;285            CLK->PWRCTL &= ~CLK_PWRCTL_HIRCEN_Msk;
000050  4803              LDR      r0,|L21.96|
000052  6800              LDR      r0,[r0,#0]
000054  2104              MOVS     r1,#4
000056  4388              BICS     r0,r0,r1
000058  4901              LDR      r1,|L21.96|
00005a  6008              STR      r0,[r1,#0]
                  |L21.92|
;;;286    }
00005c  bd70              POP      {r4-r6,pc}
;;;287    /**
                          ENDP

00005e  0000              DCW      0x0000
                  |L21.96|
                          DCD      0x50000200

                          AREA ||i.CLK_SetModuleClock||, CODE, READONLY, ALIGN=2

                  CLK_SetModuleClock PROC
;;;372      */
;;;373    void CLK_SetModuleClock(uint32_t u32ModuleIdx, uint32_t u32ClkSrc, uint32_t u32ClkDiv)
000000  b5f7              PUSH     {r0-r2,r4-r7,lr}
;;;374    {
000002  b086              SUB      sp,sp,#0x18
;;;375        uint32_t u32sel = 0, u32div = 0;
000004  2200              MOVS     r2,#0
000006  2300              MOVS     r3,#0
;;;376        uint32_t u32SelTbl[4] = {0x0, 0x4, 0xC, 0x24};
000008  4c1c              LDR      r4,|L22.124|
00000a  4625              MOV      r5,r4
00000c  cde0              LDM      r5,{r5-r7}
00000e  68e4              LDR      r4,[r4,#0xc]  ; <Data1>
000010  9704              STR      r7,[sp,#0x10]
000012  9603              STR      r6,[sp,#0xc]
000014  9502              STR      r5,[sp,#8]
000016  9405              STR      r4,[sp,#0x14]
;;;377        uint32_t u32DivTbl[2] = {0x0, 0x20};
000018  4d18              LDR      r5,|L22.124|
00001a  3510              ADDS     r5,r5,#0x10
00001c  cd30              LDM      r5,{r4,r5}
00001e  9501              STR      r5,[sp,#4]
000020  9400              STR      r4,[sp,#0]
;;;378    
;;;379        if(MODULE_CLKDIV_Msk(u32ModuleIdx) != MODULE_NoMsk)
000022  0384              LSLS     r4,r0,#14
000024  0e24              LSRS     r4,r4,#24
000026  2c00              CMP      r4,#0
000028  d010              BEQ      |L22.76|
;;;380        {
;;;381            /* Get clock divider control register address */
;;;382            u32div = (uint32_t)&CLK->CLKDIV0 + (u32DivTbl[MODULE_CLKDIV(u32ModuleIdx)]);
00002a  0304              LSLS     r4,r0,#12
00002c  0fa4              LSRS     r4,r4,#30
00002e  00a4              LSLS     r4,r4,#2
000030  466d              MOV      r5,sp
000032  592c              LDR      r4,[r5,r4]
000034  4d12              LDR      r5,|L22.128|
000036  1963              ADDS     r3,r4,r5
;;;383            /* Apply new divider */
;;;384            M32(u32div) = (M32(u32div) & (~(MODULE_CLKDIV_Msk(u32ModuleIdx) << MODULE_CLKDIV_Pos(u32ModuleIdx)))) | u32ClkDiv;
000038  0384              LSLS     r4,r0,#14
00003a  0e25              LSRS     r5,r4,#24
00003c  0584              LSLS     r4,r0,#22
00003e  0ee4              LSRS     r4,r4,#27
000040  40a5              LSLS     r5,r5,r4
000042  681c              LDR      r4,[r3,#0]
000044  43ac              BICS     r4,r4,r5
000046  9d08              LDR      r5,[sp,#0x20]
000048  432c              ORRS     r4,r4,r5
00004a  601c              STR      r4,[r3,#0]
                  |L22.76|
;;;385        }
;;;386    
;;;387        if(MODULE_CLKSEL_Msk(u32ModuleIdx) != MODULE_NoMsk)
00004c  0104              LSLS     r4,r0,#4
00004e  0f64              LSRS     r4,r4,#29
000050  2c00              CMP      r4,#0
000052  d010              BEQ      |L22.118|
;;;388        {
;;;389            /* Get clock select control register address */
;;;390            u32sel = (uint32_t)&CLK->CLKSEL0 + (u32SelTbl[MODULE_CLKSEL(u32ModuleIdx)]);
000054  0084              LSLS     r4,r0,#2
000056  0fa4              LSRS     r4,r4,#30
000058  00a4              LSLS     r4,r4,#2
00005a  ad02              ADD      r5,sp,#8
00005c  592c              LDR      r4,[r5,r4]
00005e  4d08              LDR      r5,|L22.128|
000060  3d08              SUBS     r5,r5,#8
000062  1962              ADDS     r2,r4,r5
;;;391            /* Set new clock selection setting */
;;;392            M32(u32sel) = (M32(u32sel) & (~(MODULE_CLKSEL_Msk(u32ModuleIdx) << MODULE_CLKSEL_Pos(u32ModuleIdx)))) | u32ClkSrc;
000064  0104              LSLS     r4,r0,#4
000066  0f65              LSRS     r5,r4,#29
000068  01c4              LSLS     r4,r0,#7
00006a  0ee4              LSRS     r4,r4,#27
00006c  40a5              LSLS     r5,r5,r4
00006e  6814              LDR      r4,[r2,#0]
000070  43ac              BICS     r4,r4,r5
000072  430c              ORRS     r4,r4,r1
000074  6014              STR      r4,[r2,#0]
                  |L22.118|
;;;393        }
;;;394    }
000076  b009              ADD      sp,sp,#0x24
000078  bdf0              POP      {r4-r7,pc}
;;;395    
                          ENDP

00007a  0000              DCW      0x0000
                  |L22.124|
                          DCD      ||.constdata||
                  |L22.128|
                          DCD      0x50000218

                          AREA ||i.CLK_SetSysTickClockSrc||, CODE, READONLY, ALIGN=2

                  CLK_SetSysTickClockSrc PROC
;;;407      */
;;;408    void CLK_SetSysTickClockSrc(uint32_t u32ClkSrc)
000000  4903              LDR      r1,|L23.16|
;;;409    {
;;;410        CLK->CLKSEL0 = (CLK->CLKSEL0 & ~CLK_CLKSEL0_STCLKSEL_Msk) | u32ClkSrc;
000002  6909              LDR      r1,[r1,#0x10]
000004  2238              MOVS     r2,#0x38
000006  4391              BICS     r1,r1,r2
000008  4301              ORRS     r1,r1,r0
00000a  4a01              LDR      r2,|L23.16|
00000c  6111              STR      r1,[r2,#0x10]
;;;411    }
00000e  4770              BX       lr
;;;412    
                          ENDP

                  |L23.16|
                          DCD      0x50000200

                          AREA ||i.CLK_WaitClockReady||, CODE, READONLY, ALIGN=2

                  CLK_WaitClockReady PROC
;;;693      */
;;;694    uint32_t CLK_WaitClockReady(uint32_t u32ClkMask)
000000  4601              MOV      r1,r0
;;;695    {
;;;696        int32_t i32TimeOutCnt = 2160000;
000002  4a07              LDR      r2,|L24.32|
;;;697    
;;;698        while((CLK->STATUS & u32ClkMask) != u32ClkMask)
000004  e005              B        |L24.18|
                  |L24.6|
;;;699        {
;;;700            if(i32TimeOutCnt-- <= 0)
000006  4610              MOV      r0,r2
000008  1e52              SUBS     r2,r2,#1
00000a  2800              CMP      r0,#0
00000c  dc01              BGT      |L24.18|
;;;701                return 0;
00000e  2000              MOVS     r0,#0
                  |L24.16|
;;;702        }
;;;703    
;;;704        return 1;
;;;705    }
000010  4770              BX       lr
                  |L24.18|
000012  4804              LDR      r0,|L24.36|
000014  68c0              LDR      r0,[r0,#0xc]          ;698
000016  4008              ANDS     r0,r0,r1              ;698
000018  4288              CMP      r0,r1                 ;698
00001a  d1f4              BNE      |L24.6|
00001c  2001              MOVS     r0,#1                 ;704
00001e  e7f7              B        |L24.16|
;;;706    
                          ENDP

                  |L24.32|
                          DCD      0x0020f580
                  |L24.36|
                          DCD      0x50000200

                          AREA ||.constdata||, DATA, READONLY, ALIGN=2

                          DCD      0x00000000
                          DCD      0x00000004
                          DCD      0x0000000c
                          DCD      0x00000024
                          DCD      0x00000000
                          DCD      0x00000020
                          DCD      0x00000000
                          DCD      0x00000004
                          DCD      0x0000002c
                          DCD      0x00000000
                          DCD      0x00000004
                          DCD      0x0000002c

;*** Start embedded assembler ***

#line 1 "..\\..\\..\\NUC126_Series_BSP_CMSIS_V3.00.005\\Library\\StdDriver\\src\\clk.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___5_clk_c_9b5832dc____REV16|
#line 388 "..\\..\\..\\NUC126_Series_BSP_CMSIS_V3.00.005\\Library\\CMSIS\\Include\\cmsis_armcc.h"
|__asm___5_clk_c_9b5832dc____REV16| PROC
#line 389

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___5_clk_c_9b5832dc____REVSH|
#line 402
|__asm___5_clk_c_9b5832dc____REVSH| PROC
#line 403

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
