; generated by Component: ARM Compiler 5.05 update 1 (build 106) Tool: ArmCC [4d0efa]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\obj\ao_ee24c.o --asm_dir=.\lst\ --list_dir=.\lst\ --depend=.\obj\ao_ee24c.d --cpu=Cortex-M0 --apcs=interwork -O0 --diag_suppress=9931 -I..\..\..\Library\CMSIS\Include -I..\..\..\Library\Device\Nuvoton\NUC126\Include -I..\..\..\Library\StdDriver\inc -I..\..\..\NUC126_Series_BSP_CMSIS_V3.00.005\Library\StdDriver\inc -I..\..\..\NUC126_Series_BSP_CMSIS_V3.00.005\Library\Device\Nuvoton\NUC126\Include -I..\..\..\NUC126_Series_BSP_CMSIS_V3.00.005\Library\CMSIS\Include -IC:\Keil_v5\ARM\RV31\INC -IC:\Keil_v5\ARM\CMSIS\Include -D__MICROLIB -D__UVISION_VERSION=514 --omf_browse=.\obj\ao_ee24c.crf ..\AO_EE24C.c]
                          THUMB

                          AREA ||i.SoftI2cMasterDeInit||, CODE, READONLY, ALIGN=2

                  SoftI2cMasterDeInit PROC
;;;80     // De-initialize SCL/SDA pins and set the bus low
;;;81     void SoftI2cMasterDeInit(void) 
000000  480a              LDR      r0,|L1.44|
;;;82     {
;;;83     	
;;;84     	EE_SCL_DIR_In();
000002  6800              LDR      r0,[r0,#0]
000004  21c0              MOVS     r1,#0xc0
000006  4388              BICS     r0,r0,r1
000008  30c0              ADDS     r0,r0,#0xc0
00000a  4908              LDR      r1,|L1.44|
00000c  6008              STR      r0,[r1,#0]
;;;85     	EE_SCL_PIN_Low();
00000e  2000              MOVS     r0,#0
000010  4907              LDR      r1,|L1.48|
000012  60c8              STR      r0,[r1,#0xc]
;;;86     	EE_SDA_DIR_In();
000014  4805              LDR      r0,|L1.44|
000016  6800              LDR      r0,[r0,#0]
000018  2103              MOVS     r1,#3
00001a  0209              LSLS     r1,r1,#8
00001c  4388              BICS     r0,r0,r1
00001e  1840              ADDS     r0,r0,r1
000020  4902              LDR      r1,|L1.44|
000022  6008              STR      r0,[r1,#0]
;;;87     	EE_SDA_PIN_Low();
000024  2000              MOVS     r0,#0
000026  4902              LDR      r1,|L1.48|
000028  6108              STR      r0,[r1,#0x10]
;;;88     
;;;89     }
00002a  4770              BX       lr
;;;90     
                          ENDP

                  |L1.44|
                          DCD      0x50004140
                  |L1.48|
                          DCD      0x50004340

                          AREA ||i.SoftI2cMasterInit||, CODE, READONLY, ALIGN=2

                  SoftI2cMasterInit PROC
;;;70     // Initialize SCL/SDA pins and set the bus high
;;;71     void SoftI2cMasterInit(void) {
000000  480b              LDR      r0,|L2.48|
;;;72     	
;;;73     	EE_SCL_DIR_Out();
000002  6800              LDR      r0,[r0,#0]
000004  21c0              MOVS     r1,#0xc0
000006  4388              BICS     r0,r0,r1
000008  3040              ADDS     r0,r0,#0x40
00000a  4909              LDR      r1,|L2.48|
00000c  6008              STR      r0,[r1,#0]
;;;74     	EE_SCL_PIN_High();
00000e  2001              MOVS     r0,#1
000010  4908              LDR      r1,|L2.52|
000012  60c8              STR      r0,[r1,#0xc]
;;;75     	EE_SDA_DIR_Out();
000014  4806              LDR      r0,|L2.48|
000016  6800              LDR      r0,[r0,#0]
000018  2103              MOVS     r1,#3
00001a  0209              LSLS     r1,r1,#8
00001c  4388              BICS     r0,r0,r1
00001e  30ff              ADDS     r0,r0,#0xff
000020  3001              ADDS     r0,#1
000022  4903              LDR      r1,|L2.48|
000024  6008              STR      r0,[r1,#0]
;;;76     	EE_SDA_PIN_High();
000026  2001              MOVS     r0,#1
000028  4902              LDR      r1,|L2.52|
00002a  6108              STR      r0,[r1,#0x10]
;;;77     	
;;;78     }
00002c  4770              BX       lr
;;;79     
                          ENDP

00002e  0000              DCW      0x0000
                  |L2.48|
                          DCD      0x50004140
                  |L2.52|
                          DCD      0x50004340

                          AREA ||i.SoftI2cMasterRead||, CODE, READONLY, ALIGN=2

                  SoftI2cMasterRead PROC
;;;91     // Read a byte from I2C and send Ack if more reads follow else Nak to terminate read
;;;92     uint8_t SoftI2cMasterRead(uint8_t last) 
000000  b570              PUSH     {r4-r6,lr}
;;;93     {
000002  4605              MOV      r5,r0
;;;94     	uint8_t i;
;;;95     	uint8_t b = 0;
000004  2400              MOVS     r4,#0
;;;96     	
;;;97     	// Make sure pull-up enabled
;;;98     	EE_SDA_PIN_High();
000006  2001              MOVS     r0,#1
000008  4922              LDR      r1,|L3.148|
00000a  6108              STR      r0,[r1,#0x10]
;;;99     	EE_SDA_DIR_In();
00000c  4822              LDR      r0,|L3.152|
00000e  6800              LDR      r0,[r0,#0]
000010  2103              MOVS     r1,#3
000012  0209              LSLS     r1,r1,#8
000014  4388              BICS     r0,r0,r1
000016  1840              ADDS     r0,r0,r1
000018  491f              LDR      r1,|L3.152|
00001a  6008              STR      r0,[r1,#0]
;;;100    	
;;;101    	// Read byte
;;;102    	for (i = 0; i < 8; i++) {
00001c  2600              MOVS     r6,#0
00001e  e018              B        |L3.82|
                  |L3.32|
;;;103    		// Don't change this loop unless you verify the change with a scope
;;;104    		b <<= 1;
000020  0660              LSLS     r0,r4,#25
000022  0e04              LSRS     r4,r0,#24
;;;105    		a_delay_us(I2C_DELAY_USEC);
000024  2002              MOVS     r0,#2
000026  f7fffffe          BL       a_delay_us
;;;106    		EE_SCL_PIN_High();
00002a  2001              MOVS     r0,#1
00002c  4919              LDR      r1,|L3.148|
00002e  60c8              STR      r0,[r1,#0xc]
;;;107    		a_delay_us(I2C_DELAY_USEC);
000030  2002              MOVS     r0,#2
000032  f7fffffe          BL       a_delay_us
;;;108    		if ( EE_SDA_is_High() )	b |= 1 ;
000036  4817              LDR      r0,|L3.148|
000038  6900              LDR      r0,[r0,#0x10]
00003a  2800              CMP      r0,#0
00003c  d001              BEQ      |L3.66|
00003e  2001              MOVS     r0,#1
000040  4304              ORRS     r4,r4,r0
                  |L3.66|
;;;109    		a_delay_us(I2C_DELAY_USEC);
000042  2002              MOVS     r0,#2
000044  f7fffffe          BL       a_delay_us
;;;110    		EE_SCL_PIN_Low();
000048  2000              MOVS     r0,#0
00004a  4912              LDR      r1,|L3.148|
00004c  60c8              STR      r0,[r1,#0xc]
00004e  1c70              ADDS     r0,r6,#1              ;102
000050  b2c6              UXTB     r6,r0                 ;102
                  |L3.82|
000052  2e08              CMP      r6,#8                 ;102
000054  dbe4              BLT      |L3.32|
;;;111    	}
;;;112    	// Send Ack or Nak
;;;113    	EE_SDA_DIR_Out();
000056  4810              LDR      r0,|L3.152|
000058  6800              LDR      r0,[r0,#0]
00005a  2103              MOVS     r1,#3
00005c  0209              LSLS     r1,r1,#8
00005e  4388              BICS     r0,r0,r1
000060  30ff              ADDS     r0,r0,#0xff
000062  3001              ADDS     r0,#1
000064  490c              LDR      r1,|L3.152|
000066  6008              STR      r0,[r1,#0]
;;;114    	if (last) { 
000068  2d00              CMP      r5,#0
00006a  d003              BEQ      |L3.116|
;;;115    		EE_SDA_PIN_High();
00006c  2001              MOVS     r0,#1
00006e  4909              LDR      r1,|L3.148|
000070  6108              STR      r0,[r1,#0x10]
000072  e002              B        |L3.122|
                  |L3.116|
;;;116    	} else { 
;;;117    		EE_SDA_PIN_Low();
000074  2000              MOVS     r0,#0
000076  4907              LDR      r1,|L3.148|
000078  6108              STR      r0,[r1,#0x10]
                  |L3.122|
;;;118    	}  
;;;119    	EE_SCL_PIN_High();
00007a  2001              MOVS     r0,#1
00007c  4905              LDR      r1,|L3.148|
00007e  60c8              STR      r0,[r1,#0xc]
;;;120    	a_delay_us(I2C_DELAY_USEC);
000080  2002              MOVS     r0,#2
000082  f7fffffe          BL       a_delay_us
;;;121    	EE_SCL_PIN_Low();
000086  2000              MOVS     r0,#0
000088  4902              LDR      r1,|L3.148|
00008a  60c8              STR      r0,[r1,#0xc]
;;;122    	EE_SDA_PIN_Low();
00008c  6108              STR      r0,[r1,#0x10]
;;;123    	
;;;124    	return b;
00008e  4620              MOV      r0,r4
;;;125    }
000090  bd70              POP      {r4-r6,pc}
;;;126    
                          ENDP

000092  0000              DCW      0x0000
                  |L3.148|
                          DCD      0x50004340
                  |L3.152|
                          DCD      0x50004140

                          AREA ||i.SoftI2cMasterRestart||, CODE, READONLY, ALIGN=2

                  SoftI2cMasterRestart PROC
;;;180    // Issue a restart condition
;;;181    _Bool SoftI2cMasterRestart(uint8_t addressRW) 
000000  b510              PUSH     {r4,lr}
;;;182    {
000002  4604              MOV      r4,r0
;;;183    	
;;;184    	EE_SCL_DIR_Out();
000004  480d              LDR      r0,|L4.60|
000006  6800              LDR      r0,[r0,#0]
000008  21c0              MOVS     r1,#0xc0
00000a  4388              BICS     r0,r0,r1
00000c  3040              ADDS     r0,r0,#0x40
00000e  490b              LDR      r1,|L4.60|
000010  6008              STR      r0,[r1,#0]
;;;185    	EE_SDA_DIR_Out();
000012  4608              MOV      r0,r1
000014  6800              LDR      r0,[r0,#0]
000016  2103              MOVS     r1,#3
000018  0209              LSLS     r1,r1,#8
00001a  4388              BICS     r0,r0,r1
00001c  30ff              ADDS     r0,r0,#0xff
00001e  3001              ADDS     r0,#1
000020  4906              LDR      r1,|L4.60|
000022  6008              STR      r0,[r1,#0]
;;;186    	EE_SDA_PIN_High();
000024  2001              MOVS     r0,#1
000026  4906              LDR      r1,|L4.64|
000028  6108              STR      r0,[r1,#0x10]
;;;187    	EE_SCL_PIN_High();
00002a  60c8              STR      r0,[r1,#0xc]
;;;188        a_delay_us(I2C_DELAY_USEC);
00002c  2002              MOVS     r0,#2
00002e  f7fffffe          BL       a_delay_us
;;;189    	
;;;190        return SoftI2cMasterStart(addressRW);
000032  4620              MOV      r0,r4
000034  f7fffffe          BL       SoftI2cMasterStart
;;;191    }
000038  bd10              POP      {r4,pc}
;;;192    
                          ENDP

00003a  0000              DCW      0x0000
                  |L4.60|
                          DCD      0x50004140
                  |L4.64|
                          DCD      0x50004340

                          AREA ||i.SoftI2cMasterStart||, CODE, READONLY, ALIGN=2

                  SoftI2cMasterStart PROC
;;;166    // Issue a start condition
;;;167    _Bool SoftI2cMasterStart(uint8_t addressRW) 
000000  b510              PUSH     {r4,lr}
;;;168    {
000002  4604              MOV      r4,r0
;;;169     
;;;170    	EE_SCL_DIR_Out();
000004  480f              LDR      r0,|L5.68|
000006  6800              LDR      r0,[r0,#0]
000008  21c0              MOVS     r1,#0xc0
00000a  4388              BICS     r0,r0,r1
00000c  3040              ADDS     r0,r0,#0x40
00000e  490d              LDR      r1,|L5.68|
000010  6008              STR      r0,[r1,#0]
;;;171    	EE_SDA_DIR_Out();
000012  4608              MOV      r0,r1
000014  6800              LDR      r0,[r0,#0]
000016  2103              MOVS     r1,#3
000018  0209              LSLS     r1,r1,#8
00001a  4388              BICS     r0,r0,r1
00001c  30ff              ADDS     r0,r0,#0xff
00001e  3001              ADDS     r0,#1
000020  4908              LDR      r1,|L5.68|
000022  6008              STR      r0,[r1,#0]
;;;172    	EE_SDA_PIN_Low();
000024  2000              MOVS     r0,#0
000026  4908              LDR      r1,|L5.72|
000028  6108              STR      r0,[r1,#0x10]
;;;173        a_delay_us(I2C_DELAY_USEC);
00002a  2002              MOVS     r0,#2
00002c  f7fffffe          BL       a_delay_us
;;;174    	EE_SCL_PIN_Low();
000030  2000              MOVS     r0,#0
000032  4905              LDR      r1,|L5.72|
000034  60c8              STR      r0,[r1,#0xc]
;;;175        a_delay_us(I2C_DELAY_USEC);
000036  2002              MOVS     r0,#2
000038  f7fffffe          BL       a_delay_us
;;;176    	
;;;177        return SoftI2cMasterWrite(addressRW);
00003c  4620              MOV      r0,r4
00003e  f7fffffe          BL       SoftI2cMasterWrite
;;;178    }
000042  bd10              POP      {r4,pc}
;;;179    
                          ENDP

                  |L5.68|
                          DCD      0x50004140
                  |L5.72|
                          DCD      0x50004340

                          AREA ||i.SoftI2cMasterStop||, CODE, READONLY, ALIGN=2

                  SoftI2cMasterStop PROC
;;;193    // Issue a stop condition
;;;194    void SoftI2cMasterStop(void) 
000000  b500              PUSH     {lr}
;;;195    {
;;;196    	EE_SDA_DIR_Out();
000002  480e              LDR      r0,|L6.60|
000004  6800              LDR      r0,[r0,#0]
000006  2103              MOVS     r1,#3
000008  0209              LSLS     r1,r1,#8
00000a  4388              BICS     r0,r0,r1
00000c  30ff              ADDS     r0,r0,#0xff
00000e  3001              ADDS     r0,#1
000010  490a              LDR      r1,|L6.60|
000012  6008              STR      r0,[r1,#0]
;;;197    	EE_SDA_PIN_Low();
000014  2000              MOVS     r0,#0
000016  490a              LDR      r1,|L6.64|
000018  6108              STR      r0,[r1,#0x10]
;;;198    	a_delay_us(I2C_DELAY_USEC);
00001a  2002              MOVS     r0,#2
00001c  f7fffffe          BL       a_delay_us
;;;199    	EE_SCL_PIN_High();
000020  2001              MOVS     r0,#1
000022  4907              LDR      r1,|L6.64|
000024  60c8              STR      r0,[r1,#0xc]
;;;200    	a_delay_us(I2C_DELAY_USEC);
000026  2002              MOVS     r0,#2
000028  f7fffffe          BL       a_delay_us
;;;201    	EE_SDA_PIN_High();
00002c  2001              MOVS     r0,#1
00002e  4904              LDR      r1,|L6.64|
000030  6108              STR      r0,[r1,#0x10]
;;;202    	a_delay_us(I2C_DELAY_USEC);
000032  2002              MOVS     r0,#2
000034  f7fffffe          BL       a_delay_us
;;;203    }
000038  bd00              POP      {pc}
;;;204    
                          ENDP

00003a  0000              DCW      0x0000
                  |L6.60|
                          DCD      0x50004140
                  |L6.64|
                          DCD      0x50004340

                          AREA ||i.SoftI2cMasterWrite||, CODE, READONLY, ALIGN=2

                  SoftI2cMasterWrite PROC
;;;127    // Write a byte to I2C
;;;128    _Bool SoftI2cMasterWrite(uint8_t data) 
000000  b570              PUSH     {r4-r6,lr}
;;;129    {
000002  4605              MOV      r5,r0
;;;130    	uint8_t m;
;;;131    	uint8_t rtn;
;;;132    	
;;;133    	EE_SDA_DIR_Out();
000004  4829              LDR      r0,|L7.172|
000006  6800              LDR      r0,[r0,#0]
000008  2103              MOVS     r1,#3
00000a  0209              LSLS     r1,r1,#8
00000c  4388              BICS     r0,r0,r1
00000e  30ff              ADDS     r0,r0,#0xff
000010  3001              ADDS     r0,#1
000012  4926              LDR      r1,|L7.172|
000014  6008              STR      r0,[r1,#0]
;;;134    	// Write byte
;;;135    	for (m = 0x80; m != 0; m >>= 1) 
000016  2480              MOVS     r4,#0x80
000018  e01a              B        |L7.80|
                  |L7.26|
;;;136    	{
;;;137    		// Don't change this loop unless you verify the change with a scope
;;;138    		a_delay_us(I2C_DELAY_USEC);
00001a  2002              MOVS     r0,#2
00001c  f7fffffe          BL       a_delay_us
;;;139    		if (m & data) 
000020  4620              MOV      r0,r4
000022  4028              ANDS     r0,r0,r5
000024  2800              CMP      r0,#0
000026  d003              BEQ      |L7.48|
;;;140    		{ 
;;;141    			EE_SDA_PIN_High();
000028  2001              MOVS     r0,#1
00002a  4921              LDR      r1,|L7.176|
00002c  6108              STR      r0,[r1,#0x10]
00002e  e002              B        |L7.54|
                  |L7.48|
;;;142    		} else { 
;;;143    			EE_SDA_PIN_Low();
000030  2000              MOVS     r0,#0
000032  491f              LDR      r1,|L7.176|
000034  6108              STR      r0,[r1,#0x10]
                  |L7.54|
;;;144    		}
;;;145    		a_delay_us(I2C_DELAY_USEC);
000036  2002              MOVS     r0,#2
000038  f7fffffe          BL       a_delay_us
;;;146    		EE_SCL_PIN_High();
00003c  2001              MOVS     r0,#1
00003e  491c              LDR      r1,|L7.176|
000040  60c8              STR      r0,[r1,#0xc]
;;;147    		a_delay_us(I2C_DELAY_USEC);
000042  2002              MOVS     r0,#2
000044  f7fffffe          BL       a_delay_us
;;;148    		EE_SCL_PIN_Low();
000048  2000              MOVS     r0,#0
00004a  4919              LDR      r1,|L7.176|
00004c  60c8              STR      r0,[r1,#0xc]
00004e  1064              ASRS     r4,r4,#1              ;135
                  |L7.80|
000050  2c00              CMP      r4,#0                 ;135
000052  d1e2              BNE      |L7.26|
;;;149    		
;;;150    	}      
;;;151    	// get Ack or Nak
;;;152    	// Enable pullup
;;;153    	EE_SDA_PIN_High();
000054  2001              MOVS     r0,#1
000056  4916              LDR      r1,|L7.176|
000058  6108              STR      r0,[r1,#0x10]
;;;154    	EE_SDA_DIR_In();
00005a  4814              LDR      r0,|L7.172|
00005c  6800              LDR      r0,[r0,#0]
00005e  2103              MOVS     r1,#3
000060  0209              LSLS     r1,r1,#8
000062  4388              BICS     r0,r0,r1
000064  1840              ADDS     r0,r0,r1
000066  4911              LDR      r1,|L7.172|
000068  6008              STR      r0,[r1,#0]
;;;155    	EE_SCL_PIN_High();
00006a  2001              MOVS     r0,#1
00006c  4910              LDR      r1,|L7.176|
00006e  60c8              STR      r0,[r1,#0xc]
;;;156        a_delay_us(I2C_DELAY_USEC+2);
000070  2004              MOVS     r0,#4
000072  f7fffffe          BL       a_delay_us
;;;157    	rtn = EE_SDA_is_High() ;
000076  480e              LDR      r0,|L7.176|
000078  6900              LDR      r0,[r0,#0x10]
00007a  b2c6              UXTB     r6,r0
;;;158    	EE_SCL_PIN_Low();
00007c  2000              MOVS     r0,#0
00007e  490c              LDR      r1,|L7.176|
000080  60c8              STR      r0,[r1,#0xc]
;;;159    	EE_SDA_DIR_Out();
000082  480a              LDR      r0,|L7.172|
000084  6800              LDR      r0,[r0,#0]
000086  2103              MOVS     r1,#3
000088  0209              LSLS     r1,r1,#8
00008a  4388              BICS     r0,r0,r1
00008c  30ff              ADDS     r0,r0,#0xff
00008e  3001              ADDS     r0,#1
000090  4906              LDR      r1,|L7.172|
000092  6008              STR      r0,[r1,#0]
;;;160    	EE_SDA_PIN_Low();
000094  2000              MOVS     r0,#0
000096  4906              LDR      r1,|L7.176|
000098  6108              STR      r0,[r1,#0x10]
;;;161    	a_delay_us(I2C_DELAY_USEC);
00009a  2002              MOVS     r0,#2
00009c  f7fffffe          BL       a_delay_us
;;;162    	
;;;163    	return rtn == 0;
0000a0  2e00              CMP      r6,#0
0000a2  d101              BNE      |L7.168|
0000a4  2001              MOVS     r0,#1
                  |L7.166|
;;;164    }
0000a6  bd70              POP      {r4-r6,pc}
                  |L7.168|
0000a8  2000              MOVS     r0,#0                 ;163
0000aa  e7fc              B        |L7.166|
;;;165    
                          ENDP

                  |L7.172|
                          DCD      0x50004140
                  |L7.176|
                          DCD      0x50004340

                          AREA ||i.a_delay_us||, CODE, READONLY, ALIGN=1

                  a_delay_us PROC
;;;59     
;;;60     void a_delay_us(uint8_t uSecDelay)
000000  2100              MOVS     r1,#0
;;;61     {
;;;62         uint8_t i,k;
;;;63     
;;;64         for(i=0;i<uSecDelay;i++)
000002  e008              B        |L8.22|
                  |L8.4|
;;;65         {        
;;;66         	for(k=0;k<50;k++) __NOP();
000004  2200              MOVS     r2,#0
000006  e002              B        |L8.14|
                  |L8.8|
000008  bf00              NOP      
00000a  1c53              ADDS     r3,r2,#1
00000c  b2da              UXTB     r2,r3
                  |L8.14|
00000e  2a32              CMP      r2,#0x32
000010  dbfa              BLT      |L8.8|
000012  1c4b              ADDS     r3,r1,#1              ;64
000014  b2d9              UXTB     r1,r3                 ;64
                  |L8.22|
000016  4281              CMP      r1,r0                 ;64
000018  dbf4              BLT      |L8.4|
;;;67         }
;;;68     }
00001a  4770              BX       lr
;;;69     
                          ENDP


                          AREA ||i.soft_i2c_eeprom_read_byte||, CODE, READONLY, ALIGN=1

                  soft_i2c_eeprom_read_byte PROC
;;;205    // Read 1 byte from the EEPROM device and return it
;;;206    uint8_t soft_i2c_eeprom_read_byte(uint8_t deviceAddr, uint16_t readAddress) {
000000  b570              PUSH     {r4-r6,lr}
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;207    	uint8_t byteRead = 0;
000006  2600              MOVS     r6,#0
;;;208    	
;;;209    	// Issue a start condition, send device address and write direction bit
;;;210    	if (!SoftI2cMasterStart((deviceAddr<<1) | I2C_WRITE)) return false;
000008  0661              LSLS     r1,r4,#25
00000a  0e08              LSRS     r0,r1,#24
00000c  f7fffffe          BL       SoftI2cMasterStart
000010  2800              CMP      r0,#0
000012  d100              BNE      |L9.22|
                  |L9.20|
;;;211           a_delay_us(I2C_DELAY_USEC);
;;;212    	// Send the address to read, 8 bit or 16 bit
;;;213    	//if (readAddress > 255) {
;;;214    		if (!SoftI2cMasterWrite((readAddress >> 8))) return false; // MSB
;;;215    		if (!SoftI2cMasterWrite((readAddress & 0xFF))) return false; // LSB
;;;216    	//}
;;;217    	//else {
;;;218    	//	if (!SoftI2cMasterWrite(readAddress)) return false; // 8 bit
;;;219    	//}
;;;220    
;;;221    	// Issue a repeated start condition, send device address and read direction bit
;;;222    	if (!SoftI2cMasterRestart((deviceAddr<<1) | I2C_READ)) return false;
;;;223    	a_delay_us(I2C_DELAY_USEC);
;;;224    	// Read the byte
;;;225    	byteRead = SoftI2cMasterRead(1);
;;;226    
;;;227    	// Issue a stop condition
;;;228    	SoftI2cMasterStop();
;;;229       	
;;;230    	return byteRead;
;;;231    }
000014  bd70              POP      {r4-r6,pc}
                  |L9.22|
000016  2002              MOVS     r0,#2                 ;211
000018  f7fffffe          BL       a_delay_us
00001c  1228              ASRS     r0,r5,#8              ;214
00001e  f7fffffe          BL       SoftI2cMasterWrite
000022  2800              CMP      r0,#0                 ;214
000024  d100              BNE      |L9.40|
000026  e7f5              B        |L9.20|
                  |L9.40|
000028  b2e8              UXTB     r0,r5                 ;215
00002a  f7fffffe          BL       SoftI2cMasterWrite
00002e  2800              CMP      r0,#0                 ;215
000030  d100              BNE      |L9.52|
000032  e7ef              B        |L9.20|
                  |L9.52|
000034  0061              LSLS     r1,r4,#1              ;222
000036  1c49              ADDS     r1,r1,#1              ;222
000038  b2c8              UXTB     r0,r1                 ;222
00003a  f7fffffe          BL       SoftI2cMasterRestart
00003e  2800              CMP      r0,#0                 ;222
000040  d100              BNE      |L9.68|
000042  e7e7              B        |L9.20|
                  |L9.68|
000044  2002              MOVS     r0,#2                 ;223
000046  f7fffffe          BL       a_delay_us
00004a  2001              MOVS     r0,#1                 ;225
00004c  f7fffffe          BL       SoftI2cMasterRead
000050  4606              MOV      r6,r0                 ;225
000052  f7fffffe          BL       SoftI2cMasterStop
000056  4630              MOV      r0,r6                 ;230
000058  e7dc              B        |L9.20|
;;;232    
                          ENDP


                          AREA ||i.soft_i2c_eeprom_write_byte||, CODE, READONLY, ALIGN=2

                  soft_i2c_eeprom_write_byte PROC
;;;233    // Write 1 byte to the EEPROM
;;;234    _Bool soft_i2c_eeprom_write_byte(uint8_t deviceAddr, uint16_t writeAddress, uint8_t writeByte) 
000000  b5f0              PUSH     {r4-r7,lr}
;;;235    {
000002  4606              MOV      r6,r0
000004  460c              MOV      r4,r1
000006  4617              MOV      r7,r2
;;;236    	uint8_t j;
;;;237    	// WP = Low (Disable Write Protection)
;;;238    	EE_WP_PIN_Low();
000008  2000              MOVS     r0,#0
00000a  4918              LDR      r1,|L10.108|
00000c  6008              STR      r0,[r1,#0]
;;;239    	a_delay_us(I2C_DELAY_USEC);
00000e  2002              MOVS     r0,#2
000010  f7fffffe          BL       a_delay_us
;;;240    	// Issue a start condition, send device address and write direction bit
;;;241    	if (!SoftI2cMasterStart((deviceAddr<<1) | I2C_WRITE)) return false;
000014  0671              LSLS     r1,r6,#25
000016  0e08              LSRS     r0,r1,#24
000018  f7fffffe          BL       SoftI2cMasterStart
00001c  2800              CMP      r0,#0
00001e  d100              BNE      |L10.34|
                  |L10.32|
;;;242            a_delay_us(I2C_DELAY_USEC);
;;;243    	// Send the address to write, 8 bit or 16 bit
;;;244    	//if ( writeAddress > 255) {
;;;245    		if (!SoftI2cMasterWrite((writeAddress >> 8))) return false; // MSB
;;;246    		if (!SoftI2cMasterWrite((writeAddress & 0xFF))) return false; // LSB
;;;247    	//}
;;;248    	//else {
;;;249    	//	if (!SoftI2cMasterWrite(writeAddress)) return false; // 8 bit
;;;250    	//}
;;;251    
;;;252    	// Write the byte
;;;253    	if (!SoftI2cMasterWrite(writeByte)) return false;
;;;254    
;;;255    	// Issue a stop condition
;;;256    	SoftI2cMasterStop();
;;;257    	
;;;258    	// Delay 10ms for the write to complete, depends on the EEPROM you use
;;;259    	//_delay_ms(10);
;;;260    	for ( j=0;j<10;j++) 
;;;261    	{
;;;262    		a_delay_us(100); 
;;;263    	}
;;;264    	// WP = HIGH (Enable Write Protection)
;;;265    	EE_WP_PIN_High();
;;;266    	
;;;267    	return true;
;;;268    }
000020  bdf0              POP      {r4-r7,pc}
                  |L10.34|
000022  2002              MOVS     r0,#2                 ;242
000024  f7fffffe          BL       a_delay_us
000028  1220              ASRS     r0,r4,#8              ;245
00002a  f7fffffe          BL       SoftI2cMasterWrite
00002e  2800              CMP      r0,#0                 ;245
000030  d100              BNE      |L10.52|
000032  e7f5              B        |L10.32|
                  |L10.52|
000034  b2e0              UXTB     r0,r4                 ;246
000036  f7fffffe          BL       SoftI2cMasterWrite
00003a  2800              CMP      r0,#0                 ;246
00003c  d100              BNE      |L10.64|
00003e  e7ef              B        |L10.32|
                  |L10.64|
000040  4638              MOV      r0,r7                 ;253
000042  f7fffffe          BL       SoftI2cMasterWrite
000046  2800              CMP      r0,#0                 ;253
000048  d100              BNE      |L10.76|
00004a  e7e9              B        |L10.32|
                  |L10.76|
00004c  f7fffffe          BL       SoftI2cMasterStop
000050  2500              MOVS     r5,#0                 ;260
000052  e004              B        |L10.94|
                  |L10.84|
000054  2064              MOVS     r0,#0x64              ;262
000056  f7fffffe          BL       a_delay_us
00005a  1c68              ADDS     r0,r5,#1              ;260
00005c  b2c5              UXTB     r5,r0                 ;260
                  |L10.94|
00005e  2d0a              CMP      r5,#0xa               ;260
000060  dbf8              BLT      |L10.84|
000062  2001              MOVS     r0,#1                 ;265
000064  4901              LDR      r1,|L10.108|
000066  6008              STR      r0,[r1,#0]            ;265
000068  bf00              NOP                            ;267
00006a  e7d9              B        |L10.32|
;;;269    
                          ENDP

                  |L10.108|
                          DCD      0x50004280

;*** Start embedded assembler ***

#line 1 "..\\AO_EE24C.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___10_AO_EE24C_c_cc9cfeee____REV16|
#line 388 "..\\..\\..\\NUC126_Series_BSP_CMSIS_V3.00.005\\Library\\CMSIS\\Include\\cmsis_armcc.h"
|__asm___10_AO_EE24C_c_cc9cfeee____REV16| PROC
#line 389

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___10_AO_EE24C_c_cc9cfeee____REVSH|
#line 402
|__asm___10_AO_EE24C_c_cc9cfeee____REVSH| PROC
#line 403

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
