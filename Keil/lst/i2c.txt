; generated by Component: ARM Compiler 5.05 update 1 (build 106) Tool: ArmCC [4d0efa]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\obj\i2c.o --asm_dir=.\lst\ --list_dir=.\lst\ --depend=.\obj\i2c.d --cpu=Cortex-M0 --apcs=interwork -O0 --diag_suppress=9931 -I..\..\..\Library\CMSIS\Include -I..\..\..\Library\Device\Nuvoton\NUC126\Include -I..\..\..\Library\StdDriver\inc -I..\..\..\NUC126_Series_BSP_CMSIS_V3.00.005\Library\StdDriver\inc -I..\..\..\NUC126_Series_BSP_CMSIS_V3.00.005\Library\Device\Nuvoton\NUC126\Include -I..\..\..\NUC126_Series_BSP_CMSIS_V3.00.005\Library\CMSIS\Include -IC:\Keil_v5\ARM\RV31\INC -IC:\Keil_v5\ARM\CMSIS\Include -D__MICROLIB -D__UVISION_VERSION=514 --omf_browse=.\obj\i2c.crf ..\..\..\NUC126_Series_BSP_CMSIS_V3.00.005\Library\StdDriver\src\i2c.c]
                          THUMB

                          AREA ||i.I2C_ClearTimeoutFlag||, CODE, READONLY, ALIGN=1

                  I2C_ClearTimeoutFlag PROC
;;;92       */
;;;93     void I2C_ClearTimeoutFlag(I2C_T *i2c)
000000  6941              LDR      r1,[r0,#0x14]
;;;94     {
;;;95         i2c->TOCTL |= I2C_TOCTL_TOIF_Msk;
000002  2201              MOVS     r2,#1
000004  4311              ORRS     r1,r1,r2
000006  6141              STR      r1,[r0,#0x14]
;;;96     }
000008  4770              BX       lr
;;;97     
                          ENDP


                          AREA ||i.I2C_Close||, CODE, READONLY, ALIGN=2

                  I2C_Close PROC
;;;64     
;;;65     void I2C_Close(I2C_T *i2c)
000000  4914              LDR      r1,|L2.84|
;;;66     {
;;;67         /* Reset I2C controller */
;;;68         if((uint32_t)i2c == I2C0_BASE)
000002  4288              CMP      r0,r1
000004  d10f              BNE      |L2.38|
;;;69         {
;;;70             SYS->IPRST1 |= SYS_IPRST1_I2C0RST_Msk;
000006  2105              MOVS     r1,#5
000008  0709              LSLS     r1,r1,#28
00000a  68c9              LDR      r1,[r1,#0xc]
00000c  1582              ASRS     r2,r0,#22
00000e  4311              ORRS     r1,r1,r2
000010  2205              MOVS     r2,#5
000012  0712              LSLS     r2,r2,#28
000014  60d1              STR      r1,[r2,#0xc]
;;;71             SYS->IPRST1 &= ~SYS_IPRST1_I2C0RST_Msk;
000016  4611              MOV      r1,r2
000018  68c9              LDR      r1,[r1,#0xc]
00001a  1582              ASRS     r2,r0,#22
00001c  4391              BICS     r1,r1,r2
00001e  2205              MOVS     r2,#5
000020  0712              LSLS     r2,r2,#28
000022  60d1              STR      r1,[r2,#0xc]
000024  e011              B        |L2.74|
                  |L2.38|
;;;72         }
;;;73         else if((uint32_t)i2c == I2C1_BASE)
000026  490c              LDR      r1,|L2.88|
000028  4288              CMP      r0,r1
00002a  d10e              BNE      |L2.74|
;;;74         {
;;;75             SYS->IPRST1 |= SYS_IPRST1_I2C1RST_Msk;
00002c  2105              MOVS     r1,#5
00002e  0709              LSLS     r1,r1,#28
000030  68c9              LDR      r1,[r1,#0xc]
000032  1542              ASRS     r2,r0,#21
000034  4311              ORRS     r1,r1,r2
000036  2205              MOVS     r2,#5
000038  0712              LSLS     r2,r2,#28
00003a  60d1              STR      r1,[r2,#0xc]
;;;76             SYS->IPRST1 &= ~SYS_IPRST1_I2C1RST_Msk;
00003c  4611              MOV      r1,r2
00003e  68c9              LDR      r1,[r1,#0xc]
000040  1542              ASRS     r2,r0,#21
000042  4391              BICS     r1,r1,r2
000044  2205              MOVS     r2,#5
000046  0712              LSLS     r2,r2,#28
000048  60d1              STR      r1,[r2,#0xc]
                  |L2.74|
;;;77         }
;;;78     
;;;79         /* Disable I2C */
;;;80         i2c->CTL &= ~I2C_CTL_I2CEN_Msk;
00004a  6801              LDR      r1,[r0,#0]
00004c  2240              MOVS     r2,#0x40
00004e  4391              BICS     r1,r1,r2
000050  6001              STR      r1,[r0,#0]
;;;81     }
000052  4770              BX       lr
;;;82     
                          ENDP

                  |L2.84|
                          DCD      0x40020000
                  |L2.88|
                          DCD      0x40120000

                          AREA ||i.I2C_DisableInt||, CODE, READONLY, ALIGN=1

                  I2C_DisableInt PROC
;;;137      */
;;;138    void I2C_DisableInt(I2C_T *i2c)
000000  6801              LDR      r1,[r0,#0]
;;;139    {
;;;140        i2c->CTL &= ~I2C_CTL_INTEN_Msk;
000002  2280              MOVS     r2,#0x80
000004  4391              BICS     r1,r1,r2
000006  6001              STR      r1,[r0,#0]
;;;141    }
000008  4770              BX       lr
;;;142    
                          ENDP


                          AREA ||i.I2C_DisableTimeout||, CODE, READONLY, ALIGN=1

                  I2C_DisableTimeout PROC
;;;348     */
;;;349    void I2C_DisableTimeout(I2C_T *i2c)
000000  6941              LDR      r1,[r0,#0x14]
;;;350    {
;;;351        i2c->TOCTL &= ~I2C_TOCTL_TOCEN_Msk;
000002  2204              MOVS     r2,#4
000004  4391              BICS     r1,r1,r2
000006  6141              STR      r1,[r0,#0x14]
;;;352    }
000008  4770              BX       lr
;;;353    
                          ENDP


                          AREA ||i.I2C_DisableWakeup||, CODE, READONLY, ALIGN=1

                  I2C_DisableWakeup PROC
;;;378     */
;;;379    void I2C_DisableWakeup(I2C_T *i2c)
000000  6bc1              LDR      r1,[r0,#0x3c]
;;;380    {
;;;381        i2c->WKCTL &= ~I2C_WKCTL_WKEN_Msk;
000002  0849              LSRS     r1,r1,#1
000004  0049              LSLS     r1,r1,#1
000006  63c1              STR      r1,[r0,#0x3c]
;;;382    }
000008  4770              BX       lr
;;;383    
                          ENDP


                          AREA ||i.I2C_EnableInt||, CODE, READONLY, ALIGN=1

                  I2C_EnableInt PROC
;;;152      */
;;;153    void I2C_EnableInt(I2C_T *i2c)
000000  6801              LDR      r1,[r0,#0]
;;;154    {
;;;155        i2c->CTL |= I2C_CTL_INTEN_Msk;
000002  2280              MOVS     r2,#0x80
000004  4311              ORRS     r1,r1,r2
000006  6001              STR      r1,[r0,#0]
;;;156    }
000008  4770              BX       lr
;;;157    
                          ENDP


                          AREA ||i.I2C_EnableTimeout||, CODE, READONLY, ALIGN=1

                  I2C_EnableTimeout PROC
;;;328     */
;;;329    void I2C_EnableTimeout(I2C_T *i2c, uint8_t u8LongTimeout)
000000  2900              CMP      r1,#0
;;;330    {
;;;331        if(u8LongTimeout)
000002  d004              BEQ      |L7.14|
;;;332            i2c->TOCTL |= I2C_TOCTL_TOCDIV4_Msk;
000004  6942              LDR      r2,[r0,#0x14]
000006  2302              MOVS     r3,#2
000008  431a              ORRS     r2,r2,r3
00000a  6142              STR      r2,[r0,#0x14]
00000c  e003              B        |L7.22|
                  |L7.14|
;;;333        else
;;;334            i2c->TOCTL &= ~I2C_TOCTL_TOCDIV4_Msk;
00000e  6942              LDR      r2,[r0,#0x14]
000010  2302              MOVS     r3,#2
000012  439a              BICS     r2,r2,r3
000014  6142              STR      r2,[r0,#0x14]
                  |L7.22|
;;;335    
;;;336        i2c->TOCTL |= I2C_TOCTL_TOCEN_Msk;
000016  6942              LDR      r2,[r0,#0x14]
000018  2304              MOVS     r3,#4
00001a  431a              ORRS     r2,r2,r3
00001c  6142              STR      r2,[r0,#0x14]
;;;337    }
00001e  4770              BX       lr
;;;338    
                          ENDP


                          AREA ||i.I2C_EnableWakeup||, CODE, READONLY, ALIGN=1

                  I2C_EnableWakeup PROC
;;;363     */
;;;364    void I2C_EnableWakeup(I2C_T *i2c)
000000  6bc1              LDR      r1,[r0,#0x3c]
;;;365    {
;;;366        i2c->WKCTL |= I2C_WKCTL_WKEN_Msk;
000002  2201              MOVS     r2,#1
000004  4311              ORRS     r1,r1,r2
000006  63c1              STR      r1,[r0,#0x3c]
;;;367    }
000008  4770              BX       lr
;;;368    
                          ENDP


                          AREA ||i.I2C_GetBusClockFreq||, CODE, READONLY, ALIGN=2

                  I2C_GetBusClockFreq PROC
;;;166     */
;;;167    uint32_t I2C_GetBusClockFreq(I2C_T *i2c)
000000  b570              PUSH     {r4-r6,lr}
;;;168    {
000002  4604              MOV      r4,r0
;;;169        uint32_t u32Divider = i2c->CLKDIV;
000004  6925              LDR      r5,[r4,#0x10]
;;;170    
;;;171        return (SystemCoreClock / ((u32Divider + 1) << 2));
000006  1c68              ADDS     r0,r5,#1
000008  0081              LSLS     r1,r0,#2
00000a  4802              LDR      r0,|L9.20|
00000c  6800              LDR      r0,[r0,#0]  ; SystemCoreClock
00000e  f7fffffe          BL       __aeabi_uidivmod
;;;172    }
000012  bd70              POP      {r4-r6,pc}
;;;173    
                          ENDP

                  |L9.20|
                          DCD      SystemCoreClock

                          AREA ||i.I2C_GetData||, CODE, READONLY, ALIGN=1

                  I2C_GetData PROC
;;;230     */
;;;231    uint8_t I2C_GetData(I2C_T *i2c)
000000  4601              MOV      r1,r0
;;;232    {
;;;233        return (i2c->DAT);
000002  6888              LDR      r0,[r1,#8]
000004  b2c0              UXTB     r0,r0
;;;234    }
000006  4770              BX       lr
;;;235    
                          ENDP


                          AREA ||i.I2C_GetIntFlag||, CODE, READONLY, ALIGN=1

                  I2C_GetIntFlag PROC
;;;202     */
;;;203    uint32_t I2C_GetIntFlag(I2C_T *i2c)
000000  4601              MOV      r1,r0
;;;204    {
;;;205        return ((i2c->CTL & I2C_CTL_SI_Msk) == I2C_CTL_SI_Msk ? 1 : 0);
000002  6808              LDR      r0,[r1,#0]
000004  2208              MOVS     r2,#8
000006  4010              ANDS     r0,r0,r2
000008  08c0              LSRS     r0,r0,#3
;;;206    }
00000a  4770              BX       lr
;;;207    
                          ENDP


                          AREA ||i.I2C_GetStatus||, CODE, READONLY, ALIGN=1

                  I2C_GetStatus PROC
;;;216     */
;;;217    uint32_t I2C_GetStatus(I2C_T *i2c)
000000  4601              MOV      r1,r0
;;;218    {
;;;219        return (i2c->STATUS);
000002  68c8              LDR      r0,[r1,#0xc]
;;;220    }
000004  4770              BX       lr
;;;221    
                          ENDP


                          AREA ||i.I2C_Open||, CODE, READONLY, ALIGN=2

                  I2C_Open PROC
;;;40       */
;;;41     uint32_t I2C_Open(I2C_T *i2c, uint32_t u32BusClock)
000000  b5f8              PUSH     {r3-r7,lr}
;;;42     {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;43         uint32_t u32Div;
;;;44     
;;;45         u32Div = (uint32_t)(((SystemCoreClock * 10) / (u32BusClock * 4) + 5) / 10 - 1); /* Compute proper divider for I2C clock */
000006  00a9              LSLS     r1,r5,#2
000008  4a0c              LDR      r2,|L13.60|
00000a  6812              LDR      r2,[r2,#0]  ; SystemCoreClock
00000c  230a              MOVS     r3,#0xa
00000e  435a              MULS     r2,r3,r2
000010  4610              MOV      r0,r2
000012  f7fffffe          BL       __aeabi_uidivmod
000016  1d47              ADDS     r7,r0,#5
000018  210a              MOVS     r1,#0xa
00001a  4638              MOV      r0,r7
00001c  f7fffffe          BL       __aeabi_uidivmod
000020  1e46              SUBS     r6,r0,#1
;;;46         i2c->CLKDIV = u32Div;
000022  6126              STR      r6,[r4,#0x10]
;;;47     
;;;48         /* Enable I2C */
;;;49         i2c->CTL |= I2C_CTL_I2CEN_Msk;
000024  6820              LDR      r0,[r4,#0]
000026  2140              MOVS     r1,#0x40
000028  4308              ORRS     r0,r0,r1
00002a  6020              STR      r0,[r4,#0]
;;;50     
;;;51         return (SystemCoreClock / ((u32Div + 1) << 2));
00002c  1c70              ADDS     r0,r6,#1
00002e  0081              LSLS     r1,r0,#2
000030  4802              LDR      r0,|L13.60|
000032  6800              LDR      r0,[r0,#0]  ; SystemCoreClock
000034  f7fffffe          BL       __aeabi_uidivmod
;;;52     }
000038  bdf8              POP      {r3-r7,pc}
;;;53     
                          ENDP

00003a  0000              DCW      0x0000
                  |L13.60|
                          DCD      SystemCoreClock

                          AREA ||i.I2C_ReadByte||, CODE, READONLY, ALIGN=1

                  I2C_ReadByte PROC
;;;751      */
;;;752    uint8_t I2C_ReadByte(I2C_T *i2c, uint8_t u8SlaveAddr)
000000  b5f0              PUSH     {r4-r7,lr}
;;;753    {
000002  4602              MOV      r2,r0
;;;754        uint8_t u8Xfering = 1, u8Err = 0, rdata = 0, u8Ctrl = 0;
000004  2401              MOVS     r4,#1
000006  2300              MOVS     r3,#0
000008  2000              MOVS     r0,#0
00000a  2500              MOVS     r5,#0
;;;755      
;;;756        I2C_START(i2c);                                                /* Send START */ 
00000c  6816              LDR      r6,[r2,#0]
00000e  2728              MOVS     r7,#0x28
000010  433e              ORRS     r6,r6,r7
000012  6016              STR      r6,[r2,#0]
;;;757        while(u8Xfering && (u8Err == 0))
000014  e02c              B        |L14.112|
                  |L14.22|
;;;758        { 
;;;759            I2C_WAIT_READY(i2c);
000016  bf00              NOP      
                  |L14.24|
000018  6816              LDR      r6,[r2,#0]
00001a  2708              MOVS     r7,#8
00001c  403e              ANDS     r6,r6,r7
00001e  2e00              CMP      r6,#0
000020  d0fa              BEQ      |L14.24|
;;;760            switch(I2C_GET_STATUS(i2c))
000022  68d6              LDR      r6,[r2,#0xc]
000024  2e40              CMP      r6,#0x40
000026  d00f              BEQ      |L14.72|
000028  dc04              BGT      |L14.52|
00002a  2e08              CMP      r6,#8
00002c  d007              BEQ      |L14.62|
00002e  2e38              CMP      r6,#0x38
000030  d114              BNE      |L14.92|
000032  e014              B        |L14.94|
                  |L14.52|
000034  2e48              CMP      r6,#0x48
000036  d009              BEQ      |L14.76|
000038  2e58              CMP      r6,#0x58
00003a  d10f              BNE      |L14.92|
00003c  e009              B        |L14.82|
                  |L14.62|
;;;761            {
;;;762                case 0x08:
;;;763                    I2C_SET_DATA(i2c, ((u8SlaveAddr << 1) | 0x01));    /* Write SLA+R to Register I2CDAT */
00003e  004e              LSLS     r6,r1,#1
000040  1c76              ADDS     r6,r6,#1
000042  6096              STR      r6,[r2,#8]
;;;764                    u8Ctrl = I2C_CTL_SI;                             /* Clear SI */                      
000044  2508              MOVS     r5,#8
;;;765                    break;
000046  e00d              B        |L14.100|
                  |L14.72|
;;;766                case 0x40:                                             /* Slave Address ACK */
;;;767                    u8Ctrl = I2C_CTL_SI;                             /* Clear SI */
000048  2508              MOVS     r5,#8
;;;768                    break;
00004a  e00b              B        |L14.100|
                  |L14.76|
;;;769                case 0x48:                                             /* Slave Address NACK */
;;;770                    u8Ctrl = I2C_CTL_STO_SI;                         /* Clear SI and send STOP */                
00004c  2518              MOVS     r5,#0x18
;;;771                    u8Err = 1;                
00004e  2301              MOVS     r3,#1
;;;772                    break;            
000050  e008              B        |L14.100|
                  |L14.82|
;;;773                case 0x58:
;;;774                    rdata = (unsigned char) I2C_GET_DATA(i2c);         /* Receive Data */
000052  6896              LDR      r6,[r2,#8]
000054  b2f0              UXTB     r0,r6
;;;775                    u8Ctrl = I2C_CTL_STO_SI;                         /* Clear SI and send STOP */
000056  2518              MOVS     r5,#0x18
;;;776                    u8Xfering = 0;
000058  2400              MOVS     r4,#0
;;;777                    break;
00005a  e003              B        |L14.100|
                  |L14.92|
;;;778                case 0x38:                                             /* Arbitration Lost */
00005c  bf00              NOP      
                  |L14.94|
;;;779                default:                                               /* Unknow status */
;;;780                    u8Ctrl = I2C_CTL_STO_SI;                         /* Clear SI and send STOP */                  
00005e  2518              MOVS     r5,#0x18
;;;781                    u8Err = 1;
000060  2301              MOVS     r3,#1
;;;782                    break;                
000062  bf00              NOP      
                  |L14.100|
000064  bf00              NOP                            ;765
;;;783            }
;;;784            I2C_SET_CONTROL_REG(i2c, u8Ctrl);                          /* Write controlbit to I2C_CTL register */
000066  6816              LDR      r6,[r2,#0]
000068  273c              MOVS     r7,#0x3c
00006a  43be              BICS     r6,r6,r7
00006c  432e              ORRS     r6,r6,r5
00006e  6016              STR      r6,[r2,#0]
                  |L14.112|
000070  2c00              CMP      r4,#0                 ;757
000072  d001              BEQ      |L14.120|
000074  2b00              CMP      r3,#0                 ;757
000076  d0ce              BEQ      |L14.22|
                  |L14.120|
;;;785        }
;;;786        if(u8Err)
000078  2b00              CMP      r3,#0
00007a  d000              BEQ      |L14.126|
;;;787            rdata = 0;                                                 /* If occurs error, return 0 */    
00007c  2000              MOVS     r0,#0
                  |L14.126|
;;;788        return rdata;                                                  /* Return read data */     
;;;789    }
00007e  bdf0              POP      {r4-r7,pc}
;;;790    
                          ENDP


                          AREA ||i.I2C_ReadByteOneReg||, CODE, READONLY, ALIGN=1

                  I2C_ReadByteOneReg PROC
;;;868      */
;;;869    uint8_t I2C_ReadByteOneReg(I2C_T *i2c, uint8_t u8SlaveAddr, uint8_t u8DataAddr)
000000  b5f8              PUSH     {r3-r7,lr}
;;;870    {
000002  4604              MOV      r4,r0
;;;871        uint8_t u8Xfering = 1, u8Err = 0, rdata = 0, u8Ctrl = 0;
000004  2601              MOVS     r6,#1
000006  2500              MOVS     r5,#0
000008  2000              MOVS     r0,#0
00000a  2300              MOVS     r3,#0
00000c  9300              STR      r3,[sp,#0]
;;;872      
;;;873        I2C_START(i2c);                                                /* Send START */ 
00000e  6823              LDR      r3,[r4,#0]
000010  2728              MOVS     r7,#0x28
000012  433b              ORRS     r3,r3,r7
000014  6023              STR      r3,[r4,#0]
;;;874        while(u8Xfering && (u8Err == 0))
000016  e043              B        |L15.160|
                  |L15.24|
;;;875        { 
;;;876            I2C_WAIT_READY(i2c);
000018  bf00              NOP      
                  |L15.26|
00001a  6823              LDR      r3,[r4,#0]
00001c  2708              MOVS     r7,#8
00001e  403b              ANDS     r3,r3,r7
000020  2b00              CMP      r3,#0
000022  d0fa              BEQ      |L15.26|
;;;877            switch(I2C_GET_STATUS(i2c))
000024  68e3              LDR      r3,[r4,#0xc]
000026  075f              LSLS     r7,r3,#29
000028  0f7f              LSRS     r7,r7,#29
00002a  2f00              CMP      r7,#0
00002c  d12c              BNE      |L15.136|
00002e  10df              ASRS     r7,r3,#3
000030  003b              MOVS     r3,r7
000032  f7fffffe          BL       __ARM_common_switch8
000036  0c29              DCB      0x0c,0x29
000038  07160c0e          DCB      0x07,0x16,0x0c,0x0e
00003c  130f2a1c          DCB      0x13,0x0f,0x2a,0x1c
000040  1f292329          DCB      0x1f,0x29,0x23,0x29
;;;878            {
;;;879                case 0x08:
;;;880                    I2C_SET_DATA(i2c, (u8SlaveAddr << 1 | 0x00));      /* Write SLA+W to Register I2CDAT */
000044  004b              LSLS     r3,r1,#1
000046  60a3              STR      r3,[r4,#8]
;;;881                    u8Ctrl = I2C_CTL_SI;                             /* Clear SI */                   
000048  2308              MOVS     r3,#8
00004a  9300              STR      r3,[sp,#0]
;;;882                    break;
00004c  e021              B        |L15.146|
;;;883                case 0x18:                                             /* Slave Address ACK */
;;;884                    I2C_SET_DATA(i2c, u8DataAddr);                     /* Write Lo byte address of register */
00004e  60a2              STR      r2,[r4,#8]
;;;885                    break;
000050  e01f              B        |L15.146|
;;;886                case 0x20:                                             /* Slave Address NACK */
;;;887                case 0x30:                                             /* Master transmit data NACK */                
000052  bf00              NOP      
;;;888                    u8Ctrl = I2C_CTL_STO_SI;                         /* Clear SI and send STOP */                
000054  2318              MOVS     r3,#0x18
000056  9300              STR      r3,[sp,#0]
;;;889                    u8Err = 1;                
000058  2501              MOVS     r5,#1
;;;890                    break;               
00005a  e01a              B        |L15.146|
;;;891                case 0x28:
;;;892                    u8Ctrl = I2C_CTL_STA_SI;                         /* Send repeat START */
00005c  2328              MOVS     r3,#0x28
00005e  9300              STR      r3,[sp,#0]
;;;893                    break;
000060  e017              B        |L15.146|
;;;894                case 0x10:
;;;895                    I2C_SET_DATA(i2c, ((u8SlaveAddr << 1) | 0x01));    /* Write SLA+R to Register I2CDAT */            	
000062  004b              LSLS     r3,r1,#1
000064  1c5b              ADDS     r3,r3,#1
000066  60a3              STR      r3,[r4,#8]
;;;896                    u8Ctrl = I2C_CTL_SI;            	               /* Clear SI */  
000068  2308              MOVS     r3,#8
00006a  9300              STR      r3,[sp,#0]
;;;897                    break;
00006c  e011              B        |L15.146|
;;;898                case 0x40:                                             /* Slave Address ACK */
;;;899                    u8Ctrl = I2C_CTL_SI;                             /* Clear SI */
00006e  2308              MOVS     r3,#8
000070  9300              STR      r3,[sp,#0]
;;;900                    break; 
000072  e00e              B        |L15.146|
;;;901                case 0x48:                                             /* Slave Address NACK */
;;;902                    u8Ctrl = I2C_CTL_STO_SI;                         /* Clear SI and send STOP */                
000074  2318              MOVS     r3,#0x18
000076  9300              STR      r3,[sp,#0]
;;;903                    u8Err = 1;                 
000078  2501              MOVS     r5,#1
;;;904                    break;            
00007a  e00a              B        |L15.146|
;;;905                case 0x58:
;;;906                    rdata = (uint8_t) I2C_GET_DATA(i2c);               /* Receive Data */
00007c  68a3              LDR      r3,[r4,#8]
00007e  b2d8              UXTB     r0,r3
;;;907                    u8Ctrl = I2C_CTL_STO_SI;                         /* Clear SI and send STOP */
000080  2318              MOVS     r3,#0x18
000082  9300              STR      r3,[sp,#0]
;;;908                    u8Xfering = 0;
000084  2600              MOVS     r6,#0
;;;909                    break;
000086  e004              B        |L15.146|
                  |L15.136|
;;;910                case 0x38:                                             /* Arbitration Lost */
000088  bf00              NOP      
;;;911                default:                                               /* Unknow status */
;;;912                    u8Ctrl = I2C_CTL_STO_SI;                         /* Clear SI and send STOP */                  
00008a  2318              MOVS     r3,#0x18
00008c  9300              STR      r3,[sp,#0]
;;;913                    u8Err = 1;  
00008e  2501              MOVS     r5,#1
;;;914                    break;                
000090  bf00              NOP      
                  |L15.146|
000092  bf00              NOP                            ;882
;;;915            }
;;;916            I2C_SET_CONTROL_REG(i2c, u8Ctrl);                          /* Write controlbit to I2C_CTL register */
000094  6823              LDR      r3,[r4,#0]
000096  273c              MOVS     r7,#0x3c
000098  43bb              BICS     r3,r3,r7
00009a  9f00              LDR      r7,[sp,#0]
00009c  433b              ORRS     r3,r3,r7
00009e  6023              STR      r3,[r4,#0]
                  |L15.160|
0000a0  2e00              CMP      r6,#0                 ;874
0000a2  d001              BEQ      |L15.168|
0000a4  2d00              CMP      r5,#0                 ;874
0000a6  d0b7              BEQ      |L15.24|
                  |L15.168|
;;;917        }
;;;918        if(u8Err)
0000a8  2d00              CMP      r5,#0
0000aa  d000              BEQ      |L15.174|
;;;919            rdata = 0;                                                 /* If occurs error, return 0 */    
0000ac  2000              MOVS     r0,#0
                  |L15.174|
;;;920        return rdata;                                                  /* Return read data */
;;;921    }
0000ae  bdf8              POP      {r3-r7,pc}
;;;922    
                          ENDP


                          AREA ||i.I2C_ReadByteTwoRegs||, CODE, READONLY, ALIGN=1

                  I2C_ReadByteTwoRegs PROC
;;;1010     */
;;;1011   uint8_t I2C_ReadByteTwoRegs(I2C_T *i2c, uint8_t u8SlaveAddr, uint16_t u16DataAddr)
000000  b5fc              PUSH     {r2-r7,lr}
;;;1012   {
000002  4604              MOV      r4,r0
;;;1013       uint8_t u8Xfering = 1, u8Err = 0, rdata = 0, u8Addr = 1, u8Ctrl = 0;
000004  2601              MOVS     r6,#1
000006  2500              MOVS     r5,#0
000008  2000              MOVS     r0,#0
00000a  2301              MOVS     r3,#1
00000c  9301              STR      r3,[sp,#4]
00000e  2300              MOVS     r3,#0
000010  9300              STR      r3,[sp,#0]
;;;1014    
;;;1015       I2C_START(i2c);                                                         /* Send START */
000012  6823              LDR      r3,[r4,#0]
000014  2728              MOVS     r7,#0x28
000016  433b              ORRS     r3,r3,r7
000018  6023              STR      r3,[r4,#0]
;;;1016       while(u8Xfering && (u8Err == 0))
00001a  e050              B        |L16.190|
                  |L16.28|
;;;1017       { 
;;;1018           I2C_WAIT_READY(i2c);      
00001c  bf00              NOP      
                  |L16.30|
00001e  6823              LDR      r3,[r4,#0]
000020  2708              MOVS     r7,#8
000022  403b              ANDS     r3,r3,r7
000024  2b00              CMP      r3,#0
000026  d0fa              BEQ      |L16.30|
;;;1019           switch(I2C_GET_STATUS(i2c))
000028  68e3              LDR      r3,[r4,#0xc]
00002a  075f              LSLS     r7,r3,#29
00002c  0f7f              LSRS     r7,r7,#29
00002e  2f00              CMP      r7,#0
000030  d139              BNE      |L16.166|
000032  10df              ASRS     r7,r3,#3
000034  003b              MOVS     r3,r7
000036  f7fffffe          BL       __ARM_common_switch8
00003a  0c36              DCB      0x0c,0x36
00003c  07230c13          DCB      0x07,0x23,0x0c,0x13
000040  18143729          DCB      0x18,0x14,0x37,0x29
000044  2c363036          DCB      0x2c,0x36,0x30,0x36
;;;1020           {
;;;1021               case 0x08:
;;;1022                   I2C_SET_DATA(i2c, (u8SlaveAddr << 1 | 0x00));               /* Write SLA+W to Register I2CDAT */
000048  004b              LSLS     r3,r1,#1
00004a  60a3              STR      r3,[r4,#8]
;;;1023                   u8Ctrl = I2C_CTL_SI;                                      /* Clear SI */                   
00004c  2308              MOVS     r3,#8
00004e  9300              STR      r3,[sp,#0]
;;;1024                   break;
000050  e02e              B        |L16.176|
;;;1025               case 0x18:                                                      /* Slave Address ACK */
;;;1026                   I2C_SET_DATA(i2c, (uint8_t)(u16DataAddr & 0xFF00) >> 8);    /* Write Hi byte address of register */
000052  23ff              MOVS     r3,#0xff
000054  021b              LSLS     r3,r3,#8
000056  4013              ANDS     r3,r3,r2
000058  b2db              UXTB     r3,r3
00005a  121b              ASRS     r3,r3,#8
00005c  60a3              STR      r3,[r4,#8]
;;;1027                   break;
00005e  e027              B        |L16.176|
;;;1028               case 0x20:                                                      /* Slave Address NACK */
;;;1029               case 0x30:                                                      /* Master transmit data NACK */                
000060  bf00              NOP      
;;;1030                   u8Ctrl = I2C_CTL_STO_SI;                                  /* Clear SI and send STOP */                
000062  2318              MOVS     r3,#0x18
000064  9300              STR      r3,[sp,#0]
;;;1031                   u8Err = 1;                
000066  2501              MOVS     r5,#1
;;;1032                   break;                
000068  e022              B        |L16.176|
;;;1033               case 0x28:
;;;1034                   if(u8Addr)
00006a  9b01              LDR      r3,[sp,#4]
00006c  2b00              CMP      r3,#0
00006e  d004              BEQ      |L16.122|
;;;1035                   {
;;;1036                       I2C_SET_DATA(i2c, (uint8_t)(u16DataAddr & 0xFF));       /* Write Lo byte address of register */
000070  b2d3              UXTB     r3,r2
000072  60a3              STR      r3,[r4,#8]
;;;1037                       u8Addr = 0; 
000074  2300              MOVS     r3,#0
000076  9301              STR      r3,[sp,#4]
000078  e001              B        |L16.126|
                  |L16.122|
;;;1038                   }
;;;1039                   else            
;;;1040                       u8Ctrl = I2C_CTL_STA_SI;                              /* Clear SI and send repeat START */
00007a  2328              MOVS     r3,#0x28
00007c  9300              STR      r3,[sp,#0]
                  |L16.126|
;;;1041                   break;
00007e  e017              B        |L16.176|
;;;1042               case 0x10:           
;;;1043                   I2C_SET_DATA(i2c, ((u8SlaveAddr << 1) | 0x01));             /* Write SLA+R to Register I2CDAT */
000080  004b              LSLS     r3,r1,#1
000082  1c5b              ADDS     r3,r3,#1
000084  60a3              STR      r3,[r4,#8]
;;;1044                   u8Ctrl = I2C_CTL_SI;                                      /* Clear SI */                   
000086  2308              MOVS     r3,#8
000088  9300              STR      r3,[sp,#0]
;;;1045                   break;
00008a  e011              B        |L16.176|
;;;1046               case 0x40:                                                      /* Slave Address ACK */
;;;1047                   u8Ctrl = I2C_CTL_SI;                                      /* Clear SI */
00008c  2308              MOVS     r3,#8
00008e  9300              STR      r3,[sp,#0]
;;;1048                   break; 
000090  e00e              B        |L16.176|
;;;1049               case 0x48:                                                      /* Slave Address NACK */
;;;1050                   u8Ctrl = I2C_CTL_STO_SI;                                  /* Clear SI and send STOP */                
000092  2318              MOVS     r3,#0x18
000094  9300              STR      r3,[sp,#0]
;;;1051                   u8Err = 1;                
000096  2501              MOVS     r5,#1
;;;1052                   break;            
000098  e00a              B        |L16.176|
;;;1053               case 0x58:
;;;1054                   rdata = (unsigned char) I2C_GET_DATA(i2c);                  /* Receive Data */
00009a  68a3              LDR      r3,[r4,#8]
00009c  b2d8              UXTB     r0,r3
;;;1055                   u8Ctrl = I2C_CTL_STO_SI;                                  /* Clear SI and send STOP */
00009e  2318              MOVS     r3,#0x18
0000a0  9300              STR      r3,[sp,#0]
;;;1056                   u8Xfering = 0;
0000a2  2600              MOVS     r6,#0
;;;1057                   break;
0000a4  e004              B        |L16.176|
                  |L16.166|
;;;1058               case 0x38:                                                      /* Arbitration Lost */
0000a6  bf00              NOP      
;;;1059               default:                                                        /* Unknow status */
;;;1060                   u8Ctrl = I2C_CTL_STO_SI;                                  /* Clear SI and send STOP */                
0000a8  2318              MOVS     r3,#0x18
0000aa  9300              STR      r3,[sp,#0]
;;;1061                   u8Err = 1;
0000ac  2501              MOVS     r5,#1
;;;1062                   break;
0000ae  bf00              NOP      
                  |L16.176|
0000b0  bf00              NOP                            ;1024
;;;1063           }
;;;1064           I2C_SET_CONTROL_REG(i2c, u8Ctrl);                                   /* Write controlbit to I2C_CTL register */
0000b2  6823              LDR      r3,[r4,#0]
0000b4  273c              MOVS     r7,#0x3c
0000b6  43bb              BICS     r3,r3,r7
0000b8  9f00              LDR      r7,[sp,#0]
0000ba  433b              ORRS     r3,r3,r7
0000bc  6023              STR      r3,[r4,#0]
                  |L16.190|
0000be  2e00              CMP      r6,#0                 ;1016
0000c0  d001              BEQ      |L16.198|
0000c2  2d00              CMP      r5,#0                 ;1016
0000c4  d0aa              BEQ      |L16.28|
                  |L16.198|
;;;1065       }
;;;1066       if(u8Err)
0000c6  2d00              CMP      r5,#0
0000c8  d000              BEQ      |L16.204|
;;;1067           rdata = 0;                                                          /* If occurs error, return 0 */    
0000ca  2000              MOVS     r0,#0
                  |L16.204|
;;;1068       return rdata;                                                           /* Return read data */
;;;1069   }
0000cc  bdfc              POP      {r2-r7,pc}
;;;1070   
                          ENDP


                          AREA ||i.I2C_ReadMultiBytes||, CODE, READONLY, ALIGN=1

                  I2C_ReadMultiBytes PROC
;;;805      */
;;;806    uint32_t I2C_ReadMultiBytes(I2C_T *i2c, uint8_t u8SlaveAddr, uint8_t *rdata, uint32_t u32rLen)
000000  b5fe              PUSH     {r1-r7,lr}
;;;807    {
000002  4604              MOV      r4,r0
;;;808        uint8_t u8Xfering = 1, u8Err = 0, u8Ctrl = 0; 
000004  2501              MOVS     r5,#1
000006  9502              STR      r5,[sp,#8]
000008  2500              MOVS     r5,#0
00000a  9501              STR      r5,[sp,#4]
00000c  9500              STR      r5,[sp,#0]
;;;809        uint32_t u32rxLen = 0;
00000e  2000              MOVS     r0,#0
;;;810      
;;;811        I2C_START(i2c);                                                /* Send START */ 
000010  6825              LDR      r5,[r4,#0]
000012  2628              MOVS     r6,#0x28
000014  4335              ORRS     r5,r5,r6
000016  6025              STR      r5,[r4,#0]
;;;812        while(u8Xfering && (u8Err == 0))
000018  e048              B        |L17.172|
                  |L17.26|
;;;813        { 
;;;814            I2C_WAIT_READY(i2c);
00001a  bf00              NOP      
                  |L17.28|
00001c  6825              LDR      r5,[r4,#0]
00001e  2608              MOVS     r6,#8
000020  4035              ANDS     r5,r5,r6
000022  2d00              CMP      r5,#0
000024  d0fa              BEQ      |L17.28|
;;;815            switch(I2C_GET_STATUS(i2c))
000026  68e5              LDR      r5,[r4,#0xc]
000028  2d48              CMP      r5,#0x48
00002a  d015              BEQ      |L17.88|
00002c  dc06              BGT      |L17.60|
00002e  2d08              CMP      r5,#8
000030  d009              BEQ      |L17.70|
000032  2d38              CMP      r5,#0x38
000034  d02e              BEQ      |L17.148|
000036  2d40              CMP      r5,#0x40
000038  d12b              BNE      |L17.146|
00003a  e00a              B        |L17.82|
                  |L17.60|
00003c  2d50              CMP      r5,#0x50
00003e  d010              BEQ      |L17.98|
000040  2d58              CMP      r5,#0x58
000042  d126              BNE      |L17.146|
000044  e01b              B        |L17.126|
                  |L17.70|
;;;816            {
;;;817                case 0x08:
;;;818                    I2C_SET_DATA(i2c, ((u8SlaveAddr << 1) | 0x01));    /* Write SLA+R to Register I2CDAT */
000046  004d              LSLS     r5,r1,#1
000048  1c6d              ADDS     r5,r5,#1
00004a  60a5              STR      r5,[r4,#8]
;;;819                    u8Ctrl = I2C_CTL_SI;                             /* Clear SI */                   
00004c  2508              MOVS     r5,#8
00004e  9500              STR      r5,[sp,#0]
;;;820                    break;
000050  e025              B        |L17.158|
                  |L17.82|
;;;821                case 0x40:                                             /* Slave Address ACK */
;;;822                    u8Ctrl = I2C_CTL_SI_AA;                          /* Clear SI and set ACK */
000052  250c              MOVS     r5,#0xc
000054  9500              STR      r5,[sp,#0]
;;;823                    break;
000056  e022              B        |L17.158|
                  |L17.88|
;;;824                case 0x48:                                             /* Slave Address NACK */
;;;825                    u8Ctrl = I2C_CTL_STO_SI;                         /* Clear SI and send STOP */                
000058  2518              MOVS     r5,#0x18
00005a  9500              STR      r5,[sp,#0]
;;;826                    u8Err = 1;                
00005c  2501              MOVS     r5,#1
00005e  9501              STR      r5,[sp,#4]
;;;827                    break;               
000060  e01d              B        |L17.158|
                  |L17.98|
;;;828                case 0x50:
;;;829                    rdata[u32rxLen++] = (unsigned char) I2C_GET_DATA(i2c);    /* Receive Data */
000062  68a5              LDR      r5,[r4,#8]
000064  b2ee              UXTB     r6,r5
000066  4605              MOV      r5,r0
000068  1c40              ADDS     r0,r0,#1
00006a  5556              STRB     r6,[r2,r5]
;;;830                    if(u32rxLen<(u32rLen-1))
00006c  1e5d              SUBS     r5,r3,#1
00006e  4285              CMP      r5,r0
000070  d902              BLS      |L17.120|
;;;831                    {
;;;832                        u8Ctrl = I2C_CTL_SI_AA;                             /* Clear SI and set ACK */                          
000072  250c              MOVS     r5,#0xc
000074  9500              STR      r5,[sp,#0]
000076  e001              B        |L17.124|
                  |L17.120|
;;;833                    }
;;;834                    else
;;;835                    {
;;;836                        u8Ctrl = I2C_CTL_SI;                                /* Clear SI */  
000078  2508              MOVS     r5,#8
00007a  9500              STR      r5,[sp,#0]
                  |L17.124|
;;;837                    }
;;;838                    break;
00007c  e00f              B        |L17.158|
                  |L17.126|
;;;839                case 0x58:
;;;840                    rdata[u32rxLen++] = (unsigned char) I2C_GET_DATA(i2c);    /* Receive Data */
00007e  68a5              LDR      r5,[r4,#8]
000080  b2ee              UXTB     r6,r5
000082  4605              MOV      r5,r0
000084  1c40              ADDS     r0,r0,#1
000086  5556              STRB     r6,[r2,r5]
;;;841                    u8Ctrl = I2C_CTL_STO_SI;                                /* Clear SI and send STOP */
000088  2518              MOVS     r5,#0x18
00008a  9500              STR      r5,[sp,#0]
;;;842                    u8Xfering = 0;
00008c  2500              MOVS     r5,#0
00008e  9502              STR      r5,[sp,#8]
;;;843                    break;
000090  e005              B        |L17.158|
                  |L17.146|
;;;844                case 0x38:                                                    /* Arbitration Lost */
000092  bf00              NOP      
                  |L17.148|
;;;845                default:                                                      /* Unknow status */
;;;846                    u8Ctrl = I2C_CTL_STO_SI;                                /* Clear SI and send STOP */                  
000094  2518              MOVS     r5,#0x18
000096  9500              STR      r5,[sp,#0]
;;;847                    u8Err = 1;
000098  2501              MOVS     r5,#1
00009a  9501              STR      r5,[sp,#4]
;;;848                    break;               
00009c  bf00              NOP      
                  |L17.158|
00009e  bf00              NOP                            ;820
;;;849            }
;;;850            I2C_SET_CONTROL_REG(i2c, u8Ctrl);                                 /* Write controlbit to I2C_CTL register */
0000a0  6825              LDR      r5,[r4,#0]
0000a2  263c              MOVS     r6,#0x3c
0000a4  43b5              BICS     r5,r5,r6
0000a6  9e00              LDR      r6,[sp,#0]
0000a8  4335              ORRS     r5,r5,r6
0000aa  6025              STR      r5,[r4,#0]
                  |L17.172|
0000ac  9d02              LDR      r5,[sp,#8]            ;812
0000ae  2d00              CMP      r5,#0                 ;812
0000b0  d002              BEQ      |L17.184|
0000b2  9d01              LDR      r5,[sp,#4]            ;812
0000b4  2d00              CMP      r5,#0                 ;812
0000b6  d0b0              BEQ      |L17.26|
                  |L17.184|
;;;851        }     
;;;852        return u32rxLen;                                                      /* Return bytes length that have been received */
;;;853    }
0000b8  bdfe              POP      {r1-r7,pc}
;;;854    
                          ENDP


                          AREA ||i.I2C_ReadMultiBytesOneReg||, CODE, READONLY, ALIGN=1

                  I2C_ReadMultiBytesOneReg PROC
;;;937      */
;;;938    uint32_t I2C_ReadMultiBytesOneReg(I2C_T *i2c, uint8_t u8SlaveAddr, uint8_t u8DataAddr, uint8_t *rdata, uint32_t u32rLen)
000000  b5fe              PUSH     {r1-r7,lr}
;;;939    {
000002  4604              MOV      r4,r0
000004  461d              MOV      r5,r3
;;;940        uint8_t u8Xfering = 1, u8Err = 0, u8Ctrl = 0; 
000006  2301              MOVS     r3,#1
000008  9302              STR      r3,[sp,#8]
00000a  2300              MOVS     r3,#0
00000c  9301              STR      r3,[sp,#4]
00000e  9300              STR      r3,[sp,#0]
;;;941        uint32_t u32rxLen = 0;
000010  2000              MOVS     r0,#0
;;;942      
;;;943        I2C_START(i2c);                                                /* Send START */ 
000012  6823              LDR      r3,[r4,#0]
000014  2628              MOVS     r6,#0x28
000016  4333              ORRS     r3,r3,r6
000018  6023              STR      r3,[r4,#0]
;;;944        while(u8Xfering && (u8Err == 0))
00001a  e059              B        |L18.208|
                  |L18.28|
;;;945        { 
;;;946            I2C_WAIT_READY(i2c);
00001c  bf00              NOP      
                  |L18.30|
00001e  6823              LDR      r3,[r4,#0]
000020  2608              MOVS     r6,#8
000022  4033              ANDS     r3,r3,r6
000024  2b00              CMP      r3,#0
000026  d0fa              BEQ      |L18.30|
;;;947            switch(I2C_GET_STATUS(i2c))
000028  68e3              LDR      r3,[r4,#0xc]
00002a  075e              LSLS     r6,r3,#29
00002c  0f76              LSRS     r6,r6,#29
00002e  2e00              CMP      r6,#0
000030  d141              BNE      |L18.182|
000032  10de              ASRS     r6,r3,#3
000034  0033              MOVS     r3,r6
000036  f7fffffe          BL       __ARM_common_switch8
00003a  0c3e              DCB      0x0c,0x3e
00003c  07170c0e          DCB      0x07,0x17,0x0c,0x0e
000040  140f3f1d          DCB      0x14,0x0f,0x3f,0x1d
000044  2025343e          DCB      0x20,0x25,0x34,0x3e
;;;948            {
;;;949                case 0x08:
;;;950                    I2C_SET_DATA(i2c, (u8SlaveAddr << 1 | 0x00));      /* Write SLA+W to Register I2CDAT */
000048  004b              LSLS     r3,r1,#1
00004a  60a3              STR      r3,[r4,#8]
;;;951                    u8Ctrl = I2C_CTL_SI;                             /* Clear SI */                   
00004c  2308              MOVS     r3,#8
00004e  9300              STR      r3,[sp,#0]
;;;952                    break;
000050  e037              B        |L18.194|
;;;953                case 0x18:                                             /* Slave Address ACK */
;;;954                    I2C_SET_DATA(i2c, u8DataAddr);                     /* Write Lo byte address of register */
000052  60a2              STR      r2,[r4,#8]
;;;955                    break;
000054  e035              B        |L18.194|
;;;956                case 0x20:                                             /* Slave Address NACK */
;;;957                case 0x30:                                             /* Master transmit data NACK */                
000056  bf00              NOP      
;;;958                    u8Ctrl = I2C_CTL_STO_SI;                         /* Clear SI and send STOP */                
000058  2318              MOVS     r3,#0x18
00005a  9300              STR      r3,[sp,#0]
;;;959                    u8Err = 1;                
00005c  2301              MOVS     r3,#1
00005e  9301              STR      r3,[sp,#4]
;;;960                    break;               
000060  e02f              B        |L18.194|
;;;961                case 0x28:
;;;962                    u8Ctrl = I2C_CTL_STA_SI;                         /* Send repeat START */
000062  2328              MOVS     r3,#0x28
000064  9300              STR      r3,[sp,#0]
;;;963                    break;
000066  e02c              B        |L18.194|
;;;964                case 0x10:
;;;965                    I2C_SET_DATA(i2c, ((u8SlaveAddr << 1) | 0x01));    /* Write SLA+R to Register I2CDAT */
000068  004b              LSLS     r3,r1,#1
00006a  1c5b              ADDS     r3,r3,#1
00006c  60a3              STR      r3,[r4,#8]
;;;966                    u8Ctrl = I2C_CTL_SI;                             /* Clear SI */     
00006e  2308              MOVS     r3,#8
000070  9300              STR      r3,[sp,#0]
;;;967                    break;
000072  e026              B        |L18.194|
;;;968                case 0x40:                                             /* Slave Address ACK */
;;;969                    u8Ctrl = I2C_CTL_SI_AA;                          /* Clear SI and set ACK */
000074  230c              MOVS     r3,#0xc
000076  9300              STR      r3,[sp,#0]
;;;970                    break;
000078  e023              B        |L18.194|
;;;971                case 0x48:                                             /* Slave Address NACK */
;;;972                    u8Ctrl = I2C_CTL_STO_SI;                         /* Clear SI and send STOP */                
00007a  2318              MOVS     r3,#0x18
00007c  9300              STR      r3,[sp,#0]
;;;973                    u8Err = 1;                
00007e  2301              MOVS     r3,#1
000080  9301              STR      r3,[sp,#4]
;;;974                    break;            
000082  e01e              B        |L18.194|
;;;975                case 0x50:
;;;976                    rdata[u32rxLen++] = (uint8_t) I2C_GET_DATA(i2c);   /* Receive Data */
000084  68a3              LDR      r3,[r4,#8]
000086  b2de              UXTB     r6,r3
000088  4603              MOV      r3,r0
00008a  1c40              ADDS     r0,r0,#1
00008c  54ee              STRB     r6,[r5,r3]
;;;977                    if(u32rxLen<(u32rLen-1))
00008e  9b08              LDR      r3,[sp,#0x20]
000090  1e5b              SUBS     r3,r3,#1
000092  4283              CMP      r3,r0
000094  d902              BLS      |L18.156|
;;;978                        u8Ctrl = I2C_CTL_SI_AA;                      /* Clear SI and set ACK */
000096  230c              MOVS     r3,#0xc
000098  9300              STR      r3,[sp,#0]
00009a  e001              B        |L18.160|
                  |L18.156|
;;;979                    else
;;;980                        u8Ctrl = I2C_CTL_SI;                         /* Clear SI */
00009c  2308              MOVS     r3,#8
00009e  9300              STR      r3,[sp,#0]
                  |L18.160|
;;;981                    break;              
0000a0  e00f              B        |L18.194|
;;;982                case 0x58:
;;;983                    rdata[u32rxLen++] = (uint8_t) I2C_GET_DATA(i2c);   /* Receive Data */
0000a2  68a3              LDR      r3,[r4,#8]
0000a4  b2de              UXTB     r6,r3
0000a6  4603              MOV      r3,r0
0000a8  1c40              ADDS     r0,r0,#1
0000aa  54ee              STRB     r6,[r5,r3]
;;;984                    u8Ctrl = I2C_CTL_STO_SI;                         /* Clear SI and send STOP */
0000ac  2318              MOVS     r3,#0x18
0000ae  9300              STR      r3,[sp,#0]
;;;985                    u8Xfering = 0;
0000b0  2300              MOVS     r3,#0
0000b2  9302              STR      r3,[sp,#8]
;;;986                    break;
0000b4  e005              B        |L18.194|
                  |L18.182|
;;;987                case 0x38:                                             /* Arbitration Lost */
0000b6  bf00              NOP      
;;;988                default:                                               /* Unknow status */
;;;989                    u8Ctrl = I2C_CTL_STO_SI;                         /* Clear SI and send STOP */                  
0000b8  2318              MOVS     r3,#0x18
0000ba  9300              STR      r3,[sp,#0]
;;;990                    u8Err = 1;
0000bc  2301              MOVS     r3,#1
0000be  9301              STR      r3,[sp,#4]
;;;991                    break;                
0000c0  bf00              NOP      
                  |L18.194|
0000c2  bf00              NOP                            ;952
;;;992            }
;;;993            I2C_SET_CONTROL_REG(i2c, u8Ctrl);                          /* Write controlbit to I2C_CTL register */
0000c4  6823              LDR      r3,[r4,#0]
0000c6  263c              MOVS     r6,#0x3c
0000c8  43b3              BICS     r3,r3,r6
0000ca  9e00              LDR      r6,[sp,#0]
0000cc  4333              ORRS     r3,r3,r6
0000ce  6023              STR      r3,[r4,#0]
                  |L18.208|
0000d0  9b02              LDR      r3,[sp,#8]            ;944
0000d2  2b00              CMP      r3,#0                 ;944
0000d4  d002              BEQ      |L18.220|
0000d6  9b01              LDR      r3,[sp,#4]            ;944
0000d8  2b00              CMP      r3,#0                 ;944
0000da  d09f              BEQ      |L18.28|
                  |L18.220|
;;;994        } 
;;;995        return u32rxLen;                                               /* Return bytes length that have been received */
;;;996    }
0000dc  bdfe              POP      {r1-r7,pc}
;;;997    
                          ENDP


                          AREA ||i.I2C_ReadMultiBytesTwoRegs||, CODE, READONLY, ALIGN=1

                  I2C_ReadMultiBytesTwoRegs PROC
;;;1085     */
;;;1086   uint32_t I2C_ReadMultiBytesTwoRegs(I2C_T *i2c, uint8_t u8SlaveAddr, uint16_t u16DataAddr, uint8_t *rdata, uint32_t u32rLen)
000000  b5ff              PUSH     {r0-r7,lr}
;;;1087   {
000002  4604              MOV      r4,r0
000004  461d              MOV      r5,r3
;;;1088       uint8_t u8Xfering = 1, u8Err = 0, u8Addr = 1, u8Ctrl = 0; 
000006  2301              MOVS     r3,#1
000008  9303              STR      r3,[sp,#0xc]
00000a  2300              MOVS     r3,#0
00000c  9302              STR      r3,[sp,#8]
00000e  2301              MOVS     r3,#1
000010  9301              STR      r3,[sp,#4]
000012  2300              MOVS     r3,#0
000014  9300              STR      r3,[sp,#0]
;;;1089       uint32_t u32rxLen = 0;
000016  2000              MOVS     r0,#0
;;;1090     
;;;1091       I2C_START(i2c);                                                         /* Send START */
000018  6823              LDR      r3,[r4,#0]
00001a  2628              MOVS     r6,#0x28
00001c  4333              ORRS     r3,r3,r6
00001e  6023              STR      r3,[r4,#0]
;;;1092       while(u8Xfering && (u8Err == 0))
000020  e066              B        |L19.240|
                  |L19.34|
;;;1093       { 
;;;1094           I2C_WAIT_READY(i2c);
000022  bf00              NOP      
                  |L19.36|
000024  6823              LDR      r3,[r4,#0]
000026  2608              MOVS     r6,#8
000028  4033              ANDS     r3,r3,r6
00002a  2b00              CMP      r3,#0
00002c  d0fa              BEQ      |L19.36|
;;;1095           switch(I2C_GET_STATUS(i2c))
00002e  68e3              LDR      r3,[r4,#0xc]
000030  075e              LSLS     r6,r3,#29
000032  0f76              LSRS     r6,r6,#29
000034  2e00              CMP      r6,#0
000036  d14e              BNE      |L19.214|
000038  10de              ASRS     r6,r3,#3
00003a  0033              MOVS     r3,r6
00003c  f7fffffe          BL       __ARM_common_switch8
000040  0c4b0724          DCB      0x0c,0x4b,0x07,0x24
000044  0c131914          DCB      0x0c,0x13,0x19,0x14
000048  4c2a2d32          DCB      0x4c,0x2a,0x2d,0x32
00004c  414b              DCB      0x41,0x4b
;;;1096           {
;;;1097               case 0x08:
;;;1098                   I2C_SET_DATA(i2c, (u8SlaveAddr << 1 | 0x00));               /* Write SLA+W to Register I2CDAT */
00004e  004b              LSLS     r3,r1,#1
000050  60a3              STR      r3,[r4,#8]
;;;1099                   u8Ctrl = I2C_CTL_SI;                                      /* Clear SI */                 
000052  2308              MOVS     r3,#8
000054  9300              STR      r3,[sp,#0]
;;;1100                   break;
000056  e044              B        |L19.226|
;;;1101               case 0x18:                                                      /* Slave Address ACK */
;;;1102                   I2C_SET_DATA(i2c, (uint8_t)(u16DataAddr & 0xFF00) >> 8);    /* Write Hi byte address of register */
000058  23ff              MOVS     r3,#0xff
00005a  021b              LSLS     r3,r3,#8
00005c  4013              ANDS     r3,r3,r2
00005e  b2db              UXTB     r3,r3
000060  121b              ASRS     r3,r3,#8
000062  60a3              STR      r3,[r4,#8]
;;;1103                   break;
000064  e03d              B        |L19.226|
;;;1104               case 0x20:                                                      /* Slave Address NACK */
;;;1105               case 0x30:                                                      /* Master transmit data NACK */                
000066  bf00              NOP      
;;;1106                   u8Ctrl = I2C_CTL_STO_SI;                                  /* Clear SI and send STOP */                
000068  2318              MOVS     r3,#0x18
00006a  9300              STR      r3,[sp,#0]
;;;1107                   u8Err = 1;                
00006c  2301              MOVS     r3,#1
00006e  9302              STR      r3,[sp,#8]
;;;1108                   break;               
000070  e037              B        |L19.226|
;;;1109               case 0x28:
;;;1110                   if(u8Addr)
000072  9b01              LDR      r3,[sp,#4]
000074  2b00              CMP      r3,#0
000076  d004              BEQ      |L19.130|
;;;1111                   {
;;;1112                       I2C_SET_DATA(i2c, (uint8_t)(u16DataAddr & 0xFF));       /* Write Lo byte address of register */
000078  b2d3              UXTB     r3,r2
00007a  60a3              STR      r3,[r4,#8]
;;;1113                       u8Addr = 0;                 
00007c  2300              MOVS     r3,#0
00007e  9301              STR      r3,[sp,#4]
000080  e001              B        |L19.134|
                  |L19.130|
;;;1114                   }
;;;1115                   else
;;;1116                       u8Ctrl = I2C_CTL_STA_SI;                              /* Clear SI and send repeat START */
000082  2328              MOVS     r3,#0x28
000084  9300              STR      r3,[sp,#0]
                  |L19.134|
;;;1117                   break;
000086  e02c              B        |L19.226|
;;;1118               case 0x10:               
;;;1119                   I2C_SET_DATA(i2c, ((u8SlaveAddr << 1) | 0x01));             /* Write SLA+R to Register I2CDAT */
000088  004b              LSLS     r3,r1,#1
00008a  1c5b              ADDS     r3,r3,#1
00008c  60a3              STR      r3,[r4,#8]
;;;1120                   u8Ctrl = I2C_CTL_SI;                                      /* Clear SI */            
00008e  2308              MOVS     r3,#8
000090  9300              STR      r3,[sp,#0]
;;;1121                   break;
000092  e026              B        |L19.226|
;;;1122               case 0x40:                                                      /* Slave Address ACK */
;;;1123                   u8Ctrl = I2C_CTL_SI_AA;                                   /* Clear SI and set ACK */
000094  230c              MOVS     r3,#0xc
000096  9300              STR      r3,[sp,#0]
;;;1124                   break;
000098  e023              B        |L19.226|
;;;1125               case 0x48:                                                      /* Slave Address NACK */
;;;1126                   u8Ctrl = I2C_CTL_STO_SI;                                  /* Clear SI and send STOP */                
00009a  2318              MOVS     r3,#0x18
00009c  9300              STR      r3,[sp,#0]
;;;1127                   u8Err = 1;                
00009e  2301              MOVS     r3,#1
0000a0  9302              STR      r3,[sp,#8]
;;;1128                   break;            
0000a2  e01e              B        |L19.226|
;;;1129               case 0x50:
;;;1130                   rdata[u32rxLen++] = (unsigned char) I2C_GET_DATA(i2c);      /* Receive Data */
0000a4  68a3              LDR      r3,[r4,#8]
0000a6  b2de              UXTB     r6,r3
0000a8  4603              MOV      r3,r0
0000aa  1c40              ADDS     r0,r0,#1
0000ac  54ee              STRB     r6,[r5,r3]
;;;1131                   if(u32rxLen<(u32rLen-1))
0000ae  9b09              LDR      r3,[sp,#0x24]
0000b0  1e5b              SUBS     r3,r3,#1
0000b2  4283              CMP      r3,r0
0000b4  d902              BLS      |L19.188|
;;;1132                       u8Ctrl = I2C_CTL_SI_AA;                               /* Clear SI and set ACK */
0000b6  230c              MOVS     r3,#0xc
0000b8  9300              STR      r3,[sp,#0]
0000ba  e001              B        |L19.192|
                  |L19.188|
;;;1133                   else
;;;1134                       u8Ctrl = I2C_CTL_SI;                                  /* Clear SI */
0000bc  2308              MOVS     r3,#8
0000be  9300              STR      r3,[sp,#0]
                  |L19.192|
;;;1135                   break;              
0000c0  e00f              B        |L19.226|
;;;1136               case 0x58:
;;;1137                   rdata[u32rxLen++] = (unsigned char) I2C_GET_DATA(i2c);      /* Receive Data */
0000c2  68a3              LDR      r3,[r4,#8]
0000c4  b2de              UXTB     r6,r3
0000c6  4603              MOV      r3,r0
0000c8  1c40              ADDS     r0,r0,#1
0000ca  54ee              STRB     r6,[r5,r3]
;;;1138                   u8Ctrl = I2C_CTL_STO_SI;                                  /* Clear SI and send STOP */
0000cc  2318              MOVS     r3,#0x18
0000ce  9300              STR      r3,[sp,#0]
;;;1139                   u8Xfering = 0;
0000d0  2300              MOVS     r3,#0
0000d2  9303              STR      r3,[sp,#0xc]
;;;1140                   break;
0000d4  e005              B        |L19.226|
                  |L19.214|
;;;1141               case 0x38:                                                      /* Arbitration Lost */
0000d6  bf00              NOP      
;;;1142               default:                                                        /* Unknow status */
;;;1143                   u8Ctrl = I2C_CTL_STO_SI;                                  /* Clear SI and send STOP */                  
0000d8  2318              MOVS     r3,#0x18
0000da  9300              STR      r3,[sp,#0]
;;;1144                   u8Err = 1;
0000dc  2301              MOVS     r3,#1
0000de  9302              STR      r3,[sp,#8]
;;;1145                   break;               
0000e0  bf00              NOP      
                  |L19.226|
0000e2  bf00              NOP                            ;1100
;;;1146           }
;;;1147           I2C_SET_CONTROL_REG(i2c, u8Ctrl);                                   /* Write controlbit to I2C_CTL register */
0000e4  6823              LDR      r3,[r4,#0]
0000e6  263c              MOVS     r6,#0x3c
0000e8  43b3              BICS     r3,r3,r6
0000ea  9e00              LDR      r6,[sp,#0]
0000ec  4333              ORRS     r3,r3,r6
0000ee  6023              STR      r3,[r4,#0]
                  |L19.240|
0000f0  9b03              LDR      r3,[sp,#0xc]          ;1092
0000f2  2b00              CMP      r3,#0                 ;1092
0000f4  d002              BEQ      |L19.252|
0000f6  9b02              LDR      r3,[sp,#8]            ;1092
0000f8  2b00              CMP      r3,#0                 ;1092
0000fa  d092              BEQ      |L19.34|
                  |L19.252|
;;;1148       } 
;;;1149       return u32rxLen;                                                        /* Return bytes length that have been received */
;;;1150   }
0000fc  b004              ADD      sp,sp,#0x10
0000fe  bdf0              POP      {r4-r7,pc}
;;;1151   
                          ENDP


                          AREA ||i.I2C_SetBusClockFreq||, CODE, READONLY, ALIGN=2

                  I2C_SetBusClockFreq PROC
;;;183     */
;;;184    uint32_t I2C_SetBusClockFreq(I2C_T *i2c, uint32_t u32BusClock)
000000  b5f8              PUSH     {r3-r7,lr}
;;;185    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;186        uint32_t u32Div;
;;;187    
;;;188        u32Div = (uint32_t)(((SystemCoreClock * 10) / (u32BusClock * 4) + 5) / 10 - 1); /* Compute proper divider for I2C clock */
000006  00a9              LSLS     r1,r5,#2
000008  4a0a              LDR      r2,|L20.52|
00000a  6812              LDR      r2,[r2,#0]  ; SystemCoreClock
00000c  230a              MOVS     r3,#0xa
00000e  435a              MULS     r2,r3,r2
000010  4610              MOV      r0,r2
000012  f7fffffe          BL       __aeabi_uidivmod
000016  1d47              ADDS     r7,r0,#5
000018  210a              MOVS     r1,#0xa
00001a  4638              MOV      r0,r7
00001c  f7fffffe          BL       __aeabi_uidivmod
000020  1e46              SUBS     r6,r0,#1
;;;189        i2c->CLKDIV = u32Div;
000022  6126              STR      r6,[r4,#0x10]
;;;190    
;;;191        return (SystemCoreClock / ((u32Div + 1) << 2));
000024  1c70              ADDS     r0,r6,#1
000026  0081              LSLS     r1,r0,#2
000028  4802              LDR      r0,|L20.52|
00002a  6800              LDR      r0,[r0,#0]  ; SystemCoreClock
00002c  f7fffffe          BL       __aeabi_uidivmod
;;;192    }
000030  bdf8              POP      {r3-r7,pc}
;;;193    
                          ENDP

000032  0000              DCW      0x0000
                  |L20.52|
                          DCD      SystemCoreClock

                          AREA ||i.I2C_SetData||, CODE, READONLY, ALIGN=1

                  I2C_SetData PROC
;;;245     */
;;;246    void I2C_SetData(I2C_T *i2c, uint8_t u8Data)
000000  6081              STR      r1,[r0,#8]
;;;247    {
;;;248        i2c->DAT = u8Data;
;;;249    }
000002  4770              BX       lr
;;;250    
                          ENDP


                          AREA ||i.I2C_SetSlaveAddr||, CODE, READONLY, ALIGN=1

                  I2C_SetSlaveAddr PROC
;;;264     */
;;;265    void I2C_SetSlaveAddr(I2C_T *i2c, uint8_t u8SlaveNo, uint8_t u8SlaveAddr, uint8_t u8GCMode)
000000  b510              PUSH     {r4,lr}
;;;266    {
;;;267        switch(u8SlaveNo)
000002  2900              CMP      r1,#0
000004  d013              BEQ      |L22.46|
000006  2901              CMP      r1,#1
000008  d004              BEQ      |L22.20|
00000a  2902              CMP      r1,#2
00000c  d006              BEQ      |L22.28|
00000e  2903              CMP      r1,#3
000010  d10c              BNE      |L22.44|
000012  e007              B        |L22.36|
                  |L22.20|
;;;268        {
;;;269            case 1:
;;;270                i2c->ADDR1  = (u8SlaveAddr << 1) | u8GCMode;
000014  0054              LSLS     r4,r2,#1
000016  431c              ORRS     r4,r4,r3
000018  6184              STR      r4,[r0,#0x18]
;;;271                break;
00001a  e00c              B        |L22.54|
                  |L22.28|
;;;272            case 2:
;;;273                i2c->ADDR2  = (u8SlaveAddr << 1) | u8GCMode;
00001c  0054              LSLS     r4,r2,#1
00001e  431c              ORRS     r4,r4,r3
000020  61c4              STR      r4,[r0,#0x1c]
;;;274                break;
000022  e008              B        |L22.54|
                  |L22.36|
;;;275            case 3:
;;;276                i2c->ADDR3  = (u8SlaveAddr << 1) | u8GCMode;
000024  0054              LSLS     r4,r2,#1
000026  431c              ORRS     r4,r4,r3
000028  6204              STR      r4,[r0,#0x20]
;;;277                break;
00002a  e004              B        |L22.54|
                  |L22.44|
;;;278            case 0:
00002c  bf00              NOP      
                  |L22.46|
;;;279            default:
;;;280                i2c->ADDR0  = (u8SlaveAddr << 1) | u8GCMode;
00002e  0054              LSLS     r4,r2,#1
000030  431c              ORRS     r4,r4,r3
000032  6044              STR      r4,[r0,#4]
;;;281                break;
000034  bf00              NOP      
                  |L22.54|
000036  bf00              NOP                            ;271
;;;282        }
;;;283    }
000038  bd10              POP      {r4,pc}
;;;284    
                          ENDP


                          AREA ||i.I2C_SetSlaveAddrMask||, CODE, READONLY, ALIGN=1

                  I2C_SetSlaveAddrMask PROC
;;;296     */
;;;297    void I2C_SetSlaveAddrMask(I2C_T *i2c, uint8_t u8SlaveNo, uint8_t u8SlaveAddrMask)
000000  2900              CMP      r1,#0
;;;298    {
;;;299        switch(u8SlaveNo)
000002  d010              BEQ      |L23.38|
000004  2901              CMP      r1,#1
000006  d004              BEQ      |L23.18|
000008  2902              CMP      r1,#2
00000a  d005              BEQ      |L23.24|
00000c  2903              CMP      r1,#3
00000e  d109              BNE      |L23.36|
000010  e005              B        |L23.30|
                  |L23.18|
;;;300        {
;;;301            case 1:
;;;302                i2c->ADDRMSK1  = u8SlaveAddrMask << 1;
000012  0053              LSLS     r3,r2,#1
000014  6283              STR      r3,[r0,#0x28]
;;;303                break;
000016  e009              B        |L23.44|
                  |L23.24|
;;;304            case 2:
;;;305                i2c->ADDRMSK2  = u8SlaveAddrMask << 1;
000018  0053              LSLS     r3,r2,#1
00001a  62c3              STR      r3,[r0,#0x2c]
;;;306                break;
00001c  e006              B        |L23.44|
                  |L23.30|
;;;307            case 3:
;;;308                i2c->ADDRMSK3  = u8SlaveAddrMask << 1;
00001e  0053              LSLS     r3,r2,#1
000020  6303              STR      r3,[r0,#0x30]
;;;309                break;
000022  e003              B        |L23.44|
                  |L23.36|
;;;310            case 0:
000024  bf00              NOP      
                  |L23.38|
;;;311            default:
;;;312                i2c->ADDRMSK0  = u8SlaveAddrMask << 1;
000026  0053              LSLS     r3,r2,#1
000028  6243              STR      r3,[r0,#0x24]
;;;313                break;
00002a  bf00              NOP      
                  |L23.44|
00002c  bf00              NOP                            ;303
;;;314        }
;;;315    }
00002e  4770              BX       lr
;;;316    
                          ENDP


                          AREA ||i.I2C_Trigger||, CODE, READONLY, ALIGN=1

                  I2C_Trigger PROC
;;;111      */
;;;112    void I2C_Trigger(I2C_T *i2c, uint8_t u8Start, uint8_t u8Stop, uint8_t u8Si, uint8_t u8Ack)
000000  b5f0              PUSH     {r4-r7,lr}
;;;113    {
000002  9c05              LDR      r4,[sp,#0x14]
;;;114        uint32_t u32Reg = 0;
000004  2500              MOVS     r5,#0
;;;115    
;;;116        if(u8Start)
000006  2900              CMP      r1,#0
000008  d001              BEQ      |L24.14|
;;;117            u32Reg |= I2C_CTL_STA;
00000a  2620              MOVS     r6,#0x20
00000c  4335              ORRS     r5,r5,r6
                  |L24.14|
;;;118        if(u8Stop)
00000e  2a00              CMP      r2,#0
000010  d001              BEQ      |L24.22|
;;;119            u32Reg |= I2C_CTL_STO;
000012  2610              MOVS     r6,#0x10
000014  4335              ORRS     r5,r5,r6
                  |L24.22|
;;;120        if(u8Si)
000016  2b00              CMP      r3,#0
000018  d001              BEQ      |L24.30|
;;;121            u32Reg |= I2C_CTL_SI;
00001a  2608              MOVS     r6,#8
00001c  4335              ORRS     r5,r5,r6
                  |L24.30|
;;;122        if(u8Ack)
00001e  2c00              CMP      r4,#0
000020  d001              BEQ      |L24.38|
;;;123            u32Reg |= I2C_CTL_AA;
000022  2604              MOVS     r6,#4
000024  4335              ORRS     r5,r5,r6
                  |L24.38|
;;;124    
;;;125        i2c->CTL = (i2c->CTL & ~0x3C) | u32Reg;
000026  6806              LDR      r6,[r0,#0]
000028  273c              MOVS     r7,#0x3c
00002a  43be              BICS     r6,r6,r7
00002c  432e              ORRS     r6,r6,r5
00002e  6006              STR      r6,[r0,#0]
;;;126    }
000030  bdf0              POP      {r4-r7,pc}
;;;127    
                          ENDP


                          AREA ||i.I2C_WriteByte||, CODE, READONLY, ALIGN=1

                  I2C_WriteByte PROC
;;;397    
;;;398    uint8_t I2C_WriteByte(I2C_T *i2c, uint8_t u8SlaveAddr, const uint8_t data)
000000  b5f0              PUSH     {r4-r7,lr}
;;;399    {
000002  4603              MOV      r3,r0
;;;400        uint8_t u8Xfering = 1, u8Err = 0, u8Ctrl = 0;
000004  2401              MOVS     r4,#1
000006  2500              MOVS     r5,#0
000008  2600              MOVS     r6,#0
;;;401      
;;;402        I2C_START(i2c);
00000a  6818              LDR      r0,[r3,#0]
00000c  2728              MOVS     r7,#0x28
00000e  4338              ORRS     r0,r0,r7
000010  6018              STR      r0,[r3,#0]
;;;403        while(u8Xfering && (u8Err == 0))
000012  e02c              B        |L25.110|
                  |L25.20|
;;;404        {
;;;405            I2C_WAIT_READY(i2c);
000014  bf00              NOP      
                  |L25.22|
000016  6818              LDR      r0,[r3,#0]
000018  2708              MOVS     r7,#8
00001a  4038              ANDS     r0,r0,r7
00001c  2800              CMP      r0,#0
00001e  d0fa              BEQ      |L25.22|
;;;406            switch(I2C_GET_STATUS(i2c))
000020  68d8              LDR      r0,[r3,#0xc]
000022  2828              CMP      r0,#0x28
000024  d016              BEQ      |L25.84|
000026  dc06              BGT      |L25.54|
000028  2808              CMP      r0,#8
00002a  d009              BEQ      |L25.64|
00002c  2818              CMP      r0,#0x18
00002e  d00b              BEQ      |L25.72|
000030  2820              CMP      r0,#0x20
000032  d112              BNE      |L25.90|
000034  e00a              B        |L25.76|
                  |L25.54|
000036  2830              CMP      r0,#0x30
000038  d009              BEQ      |L25.78|
00003a  2838              CMP      r0,#0x38
00003c  d10d              BNE      |L25.90|
00003e  e00d              B        |L25.92|
                  |L25.64|
;;;407            {
;;;408                case 0x08:
;;;409                    I2C_SET_DATA(i2c, (u8SlaveAddr << 1 | 0x00));    /* Write SLA+W to Register I2CDAT */
000040  0048              LSLS     r0,r1,#1
000042  6098              STR      r0,[r3,#8]
;;;410                    u8Ctrl = I2C_CTL_SI;                           /* Clear SI */            
000044  2608              MOVS     r6,#8
;;;411                    break;
000046  e00c              B        |L25.98|
                  |L25.72|
;;;412                case 0x18:                                           /* Slave Address ACK */
;;;413                    I2C_SET_DATA(i2c, data);                         /* Write data to I2CDAT */
000048  609a              STR      r2,[r3,#8]
;;;414                    break;
00004a  e00a              B        |L25.98|
                  |L25.76|
;;;415                case 0x20:                                           /* Slave Address NACK */
;;;416                case 0x30:                                           /* Master transmit data NACK */
00004c  bf00              NOP      
                  |L25.78|
;;;417                    u8Ctrl = I2C_CTL_STO_SI;                       /* Clear SI and send STOP */                
00004e  2618              MOVS     r6,#0x18
;;;418                    u8Err = 1;                
000050  2501              MOVS     r5,#1
;;;419                    break;             
000052  e006              B        |L25.98|
                  |L25.84|
;;;420                case 0x28:
;;;421                    u8Ctrl = I2C_CTL_STO_SI;                       /* Clear SI and send STOP */
000054  2618              MOVS     r6,#0x18
;;;422                    u8Xfering = 0;
000056  2400              MOVS     r4,#0
;;;423                    break;
000058  e003              B        |L25.98|
                  |L25.90|
;;;424                case 0x38:                                           /* Arbitration Lost */
00005a  bf00              NOP      
                  |L25.92|
;;;425                default:                                             /* Unknow status */
;;;426                    u8Ctrl = I2C_CTL_STO_SI;                       /* Clear SI and send STOP */                  
00005c  2618              MOVS     r6,#0x18
;;;427                    u8Err = 1;
00005e  2501              MOVS     r5,#1
;;;428                    break;
000060  bf00              NOP      
                  |L25.98|
000062  bf00              NOP                            ;411
;;;429            }
;;;430            I2C_SET_CONTROL_REG(i2c, u8Ctrl);                        /* Write controlbit to I2C_CTL register */ 
000064  6818              LDR      r0,[r3,#0]
000066  273c              MOVS     r7,#0x3c
000068  43b8              BICS     r0,r0,r7
00006a  4330              ORRS     r0,r0,r6
00006c  6018              STR      r0,[r3,#0]
                  |L25.110|
00006e  2c00              CMP      r4,#0                 ;403
000070  d001              BEQ      |L25.118|
000072  2d00              CMP      r5,#0                 ;403
000074  d0ce              BEQ      |L25.20|
                  |L25.118|
;;;431        } 
;;;432        return (u8Err | u8Xfering);                                  /* return (Success)/(Fail) status */
000076  4628              MOV      r0,r5
000078  4320              ORRS     r0,r0,r4
;;;433    }
00007a  bdf0              POP      {r4-r7,pc}
;;;434    
                          ENDP


                          AREA ||i.I2C_WriteByteOneReg||, CODE, READONLY, ALIGN=1

                  I2C_WriteByteOneReg PROC
;;;504    
;;;505    uint8_t I2C_WriteByteOneReg(I2C_T *i2c, uint8_t u8SlaveAddr, uint8_t u8DataAddr, const uint8_t data)
000000  b5ff              PUSH     {r0-r7,lr}
;;;506    {
000002  b081              SUB      sp,sp,#4
000004  4604              MOV      r4,r0
;;;507        uint8_t u8Xfering = 1, u8Err = 0, u8Ctrl = 0;
000006  2301              MOVS     r3,#1
000008  2500              MOVS     r5,#0
00000a  2000              MOVS     r0,#0
00000c  9000              STR      r0,[sp,#0]
;;;508        uint32_t u32txLen = 0;
00000e  2600              MOVS     r6,#0
;;;509      
;;;510        I2C_START(i2c);                                              /* Send START */
000010  6820              LDR      r0,[r4,#0]
000012  2728              MOVS     r7,#0x28
000014  4338              ORRS     r0,r0,r7
000016  6020              STR      r0,[r4,#0]
;;;511        while(u8Xfering && (u8Err == 0))
000018  e037              B        |L26.138|
                  |L26.26|
;;;512        {
;;;513            I2C_WAIT_READY(i2c);
00001a  bf00              NOP      
                  |L26.28|
00001c  6820              LDR      r0,[r4,#0]
00001e  2708              MOVS     r7,#8
000020  4038              ANDS     r0,r0,r7
000022  2800              CMP      r0,#0
000024  d0fa              BEQ      |L26.28|
;;;514            switch(I2C_GET_STATUS(i2c))
000026  68e0              LDR      r0,[r4,#0xc]
000028  2828              CMP      r0,#0x28
00002a  d018              BEQ      |L26.94|
00002c  dc06              BGT      |L26.60|
00002e  2808              CMP      r0,#8
000030  d009              BEQ      |L26.70|
000032  2818              CMP      r0,#0x18
000034  d00c              BEQ      |L26.80|
000036  2820              CMP      r0,#0x20
000038  d11b              BNE      |L26.114|
00003a  e00b              B        |L26.84|
                  |L26.60|
00003c  2830              CMP      r0,#0x30
00003e  d00a              BEQ      |L26.86|
000040  2838              CMP      r0,#0x38
000042  d116              BNE      |L26.114|
000044  e016              B        |L26.116|
                  |L26.70|
;;;515            {
;;;516                case 0x08:
;;;517                    I2C_SET_DATA(i2c, (u8SlaveAddr << 1 | 0x00));    /* Send Slave address with write bit */
000046  0048              LSLS     r0,r1,#1
000048  60a0              STR      r0,[r4,#8]
;;;518                    u8Ctrl = I2C_CTL_SI;                           /* Clear SI */
00004a  2008              MOVS     r0,#8
00004c  9000              STR      r0,[sp,#0]
;;;519                    break;
00004e  e015              B        |L26.124|
                  |L26.80|
;;;520                case 0x18:                                           /* Slave Address ACK */
;;;521                    I2C_SET_DATA(i2c, u8DataAddr);                   /* Write Lo byte address of register */ 
000050  60a2              STR      r2,[r4,#8]
;;;522                    break;
000052  e013              B        |L26.124|
                  |L26.84|
;;;523                case 0x20:                                           /* Slave Address NACK */
;;;524                case 0x30:                                           /* Master transmit data NACK */                
000054  bf00              NOP      
                  |L26.86|
;;;525                    u8Ctrl = I2C_CTL_STO_SI;                       /* Clear SI and send STOP */                
000056  2018              MOVS     r0,#0x18
000058  9000              STR      r0,[sp,#0]
;;;526                    u8Err = 1;                
00005a  2501              MOVS     r5,#1
;;;527                    break;             
00005c  e00e              B        |L26.124|
                  |L26.94|
;;;528                case 0x28:
;;;529                    if(u32txLen < 1)
00005e  2e00              CMP      r6,#0
000060  d103              BNE      |L26.106|
;;;530                    {
;;;531                        I2C_SET_DATA(i2c, data);
000062  9804              LDR      r0,[sp,#0x10]
000064  60a0              STR      r0,[r4,#8]
;;;532                        u32txLen++;
000066  1c76              ADDS     r6,r6,#1
000068  e002              B        |L26.112|
                  |L26.106|
;;;533                    }
;;;534                    else
;;;535                    {
;;;536                        u8Ctrl = I2C_CTL_STO_SI;                   /* Clear SI and send STOP */
00006a  2018              MOVS     r0,#0x18
00006c  9000              STR      r0,[sp,#0]
;;;537                        u8Xfering = 0;
00006e  2300              MOVS     r3,#0
                  |L26.112|
;;;538                    }                 
;;;539                    break;
000070  e004              B        |L26.124|
                  |L26.114|
;;;540                case 0x38:                                           /* Arbitration Lost */
000072  bf00              NOP      
                  |L26.116|
;;;541                default:                                             /* Unknow status */
;;;542                    u8Ctrl = I2C_CTL_STO_SI;                       /* Clear SI and send STOP */                  
000074  2018              MOVS     r0,#0x18
000076  9000              STR      r0,[sp,#0]
;;;543                    u8Err = 1;
000078  2501              MOVS     r5,#1
;;;544                    break;
00007a  bf00              NOP      
                  |L26.124|
00007c  bf00              NOP                            ;519
;;;545            }
;;;546            I2C_SET_CONTROL_REG(i2c, u8Ctrl);                        /* Write controlbit to I2C_CTL register */        
00007e  6820              LDR      r0,[r4,#0]
000080  273c              MOVS     r7,#0x3c
000082  43b8              BICS     r0,r0,r7
000084  9f00              LDR      r7,[sp,#0]
000086  4338              ORRS     r0,r0,r7
000088  6020              STR      r0,[r4,#0]
                  |L26.138|
00008a  2b00              CMP      r3,#0                 ;511
00008c  d001              BEQ      |L26.146|
00008e  2d00              CMP      r5,#0                 ;511
000090  d0c3              BEQ      |L26.26|
                  |L26.146|
;;;547        }
;;;548        return (u8Err | u8Xfering);                                  /* return (Success)/(Fail) status */
000092  4628              MOV      r0,r5
000094  4318              ORRS     r0,r0,r3
;;;549    }
000096  b005              ADD      sp,sp,#0x14
000098  bdf0              POP      {r4-r7,pc}
;;;550    
                          ENDP


                          AREA ||i.I2C_WriteByteTwoRegs||, CODE, READONLY, ALIGN=1

                  I2C_WriteByteTwoRegs PROC
;;;625    
;;;626    uint8_t I2C_WriteByteTwoRegs(I2C_T *i2c, uint8_t u8SlaveAddr, uint16_t u16DataAddr, const uint8_t data)
000000  b5ff              PUSH     {r0-r7,lr}
;;;627    {
000002  b081              SUB      sp,sp,#4
000004  4604              MOV      r4,r0
;;;628        uint8_t u8Xfering = 1, u8Err = 0, u8Addr = 1, u8Ctrl = 0;
000006  2101              MOVS     r1,#1
000008  2300              MOVS     r3,#0
00000a  2501              MOVS     r5,#1
00000c  2000              MOVS     r0,#0
00000e  9000              STR      r0,[sp,#0]
;;;629        uint32_t u32txLen = 0;
000010  2600              MOVS     r6,#0
;;;630      
;;;631        I2C_START(i2c);                                                         /* Send START */
000012  6820              LDR      r0,[r4,#0]
000014  2728              MOVS     r7,#0x28
000016  4338              ORRS     r0,r0,r7
000018  6020              STR      r0,[r4,#0]
;;;632        while(u8Xfering && (u8Err == 0))
00001a  e045              B        |L27.168|
                  |L27.28|
;;;633        {
;;;634            I2C_WAIT_READY(i2c);
00001c  bf00              NOP      
                  |L27.30|
00001e  6820              LDR      r0,[r4,#0]
000020  2708              MOVS     r7,#8
000022  4038              ANDS     r0,r0,r7
000024  2800              CMP      r0,#0
000026  d0fa              BEQ      |L27.30|
;;;635            switch(I2C_GET_STATUS(i2c))
000028  68e0              LDR      r0,[r4,#0xc]
00002a  2828              CMP      r0,#0x28
00002c  d01e              BEQ      |L27.108|
00002e  dc06              BGT      |L27.62|
000030  2808              CMP      r0,#8
000032  d009              BEQ      |L27.72|
000034  2818              CMP      r0,#0x18
000036  d00d              BEQ      |L27.84|
000038  2820              CMP      r0,#0x20
00003a  d129              BNE      |L27.144|
00003c  e011              B        |L27.98|
                  |L27.62|
00003e  2830              CMP      r0,#0x30
000040  d010              BEQ      |L27.100|
000042  2838              CMP      r0,#0x38
000044  d124              BNE      |L27.144|
000046  e024              B        |L27.146|
                  |L27.72|
;;;636            {
;;;637                case 0x08:
;;;638                    I2C_SET_DATA(i2c, (u8SlaveAddr << 1 | 0x00));               /* Write SLA+W to Register I2CDAT */
000048  9802              LDR      r0,[sp,#8]
00004a  0040              LSLS     r0,r0,#1
00004c  60a0              STR      r0,[r4,#8]
;;;639                    u8Ctrl = I2C_CTL_SI;                                      /* Clear SI */
00004e  2008              MOVS     r0,#8
000050  9000              STR      r0,[sp,#0]
;;;640                    break;
000052  e022              B        |L27.154|
                  |L27.84|
;;;641                case 0x18:                                                      /* Slave Address ACK */
;;;642                    I2C_SET_DATA(i2c, (uint8_t)(u16DataAddr & 0xFF00) >> 8);    /* Write Hi byte address of register */
000054  20ff              MOVS     r0,#0xff
000056  0200              LSLS     r0,r0,#8
000058  4010              ANDS     r0,r0,r2
00005a  b2c0              UXTB     r0,r0
00005c  1200              ASRS     r0,r0,#8
00005e  60a0              STR      r0,[r4,#8]
;;;643                    break; 
000060  e01b              B        |L27.154|
                  |L27.98|
;;;644                case 0x20:                                                      /* Slave Address NACK */
;;;645                case 0x30:                                                      /* Master transmit data NACK */                
000062  bf00              NOP      
                  |L27.100|
;;;646                    u8Ctrl = I2C_CTL_STO_SI;                                  /* Clear SI and send STOP */                
000064  2018              MOVS     r0,#0x18
000066  9000              STR      r0,[sp,#0]
;;;647                    u8Err = 1;                
000068  2301              MOVS     r3,#1
;;;648                    break;              
00006a  e016              B        |L27.154|
                  |L27.108|
;;;649                case 0x28:
;;;650                    if(u8Addr)
00006c  2d00              CMP      r5,#0
00006e  d003              BEQ      |L27.120|
;;;651                    {
;;;652                        I2C_SET_DATA(i2c, (uint8_t)(u16DataAddr & 0xFF));       /* Write Lo byte address of register */
000070  b2d0              UXTB     r0,r2
000072  60a0              STR      r0,[r4,#8]
;;;653                        u8Addr = 0;
000074  2500              MOVS     r5,#0
000076  e00a              B        |L27.142|
                  |L27.120|
;;;654                    }
;;;655                    else if((u32txLen < 1) && (u8Addr == 0))
000078  2e00              CMP      r6,#0
00007a  d105              BNE      |L27.136|
00007c  2d00              CMP      r5,#0
00007e  d103              BNE      |L27.136|
;;;656                    {
;;;657                        I2C_SET_DATA(i2c, data);
000080  9804              LDR      r0,[sp,#0x10]
000082  60a0              STR      r0,[r4,#8]
;;;658                        u32txLen++;
000084  1c76              ADDS     r6,r6,#1
000086  e002              B        |L27.142|
                  |L27.136|
;;;659                    }
;;;660                    else
;;;661                    {
;;;662                        u8Ctrl = I2C_CTL_STO_SI;                              /* Clear SI and send STOP */
000088  2018              MOVS     r0,#0x18
00008a  9000              STR      r0,[sp,#0]
;;;663                        u8Xfering = 0;
00008c  2100              MOVS     r1,#0
                  |L27.142|
;;;664                    }
;;;665                    break;
00008e  e004              B        |L27.154|
                  |L27.144|
;;;666                case 0x38:                                                      /* Arbitration Lost */
000090  bf00              NOP      
                  |L27.146|
;;;667                default:                                                        /* Unknow status */
;;;668                    u8Ctrl = I2C_CTL_STO_SI;                                  /* Clear SI and send STOP */                  
000092  2018              MOVS     r0,#0x18
000094  9000              STR      r0,[sp,#0]
;;;669                    u8Err = 1;
000096  2301              MOVS     r3,#1
;;;670                    break;
000098  bf00              NOP      
                  |L27.154|
00009a  bf00              NOP                            ;640
;;;671            }
;;;672            I2C_SET_CONTROL_REG(i2c, u8Ctrl);                                   /* Write controlbit to I2C_CTL register */  
00009c  6820              LDR      r0,[r4,#0]
00009e  273c              MOVS     r7,#0x3c
0000a0  43b8              BICS     r0,r0,r7
0000a2  9f00              LDR      r7,[sp,#0]
0000a4  4338              ORRS     r0,r0,r7
0000a6  6020              STR      r0,[r4,#0]
                  |L27.168|
0000a8  2900              CMP      r1,#0                 ;632
0000aa  d001              BEQ      |L27.176|
0000ac  2b00              CMP      r3,#0                 ;632
0000ae  d0b5              BEQ      |L27.28|
                  |L27.176|
;;;673        }
;;;674        return (u8Err | u8Xfering);                                             /* return (Success)/(Fail) status */
0000b0  4618              MOV      r0,r3
0000b2  4308              ORRS     r0,r0,r1
;;;675    }
0000b4  b005              ADD      sp,sp,#0x14
0000b6  bdf0              POP      {r4-r7,pc}
;;;676    
                          ENDP


                          AREA ||i.I2C_WriteMultiBytes||, CODE, READONLY, ALIGN=1

                  I2C_WriteMultiBytes PROC
;;;448    
;;;449    uint32_t I2C_WriteMultiBytes(I2C_T *i2c, uint8_t u8SlaveAddr, const uint8_t *data, uint32_t u32wLen)
000000  b5fc              PUSH     {r2-r7,lr}
;;;450    {
000002  4604              MOV      r4,r0
;;;451        uint8_t u8Xfering = 1, u8Err = 0, u8Ctrl = 0;
000004  2501              MOVS     r5,#1
000006  2600              MOVS     r6,#0
000008  9601              STR      r6,[sp,#4]
00000a  9600              STR      r6,[sp,#0]
;;;452        uint32_t u32txLen = 0;
00000c  2000              MOVS     r0,#0
;;;453      
;;;454        I2C_START(i2c);                                              /* Send START */
00000e  6826              LDR      r6,[r4,#0]
000010  2728              MOVS     r7,#0x28
000012  433e              ORRS     r6,r6,r7
000014  6026              STR      r6,[r4,#0]
;;;455        while(u8Xfering && (u8Err == 0))
000016  e039              B        |L28.140|
                  |L28.24|
;;;456        {
;;;457            I2C_WAIT_READY(i2c);
000018  bf00              NOP      
                  |L28.26|
00001a  6826              LDR      r6,[r4,#0]
00001c  2708              MOVS     r7,#8
00001e  403e              ANDS     r6,r6,r7
000020  2e00              CMP      r6,#0
000022  d0fa              BEQ      |L28.26|
;;;458            switch(I2C_GET_STATUS(i2c))
000024  68e6              LDR      r6,[r4,#0xc]
000026  2e28              CMP      r6,#0x28
000028  d012              BEQ      |L28.80|
00002a  dc06              BGT      |L28.58|
00002c  2e08              CMP      r6,#8
00002e  d009              BEQ      |L28.68|
000030  2e18              CMP      r6,#0x18
000032  d00c              BEQ      |L28.78|
000034  2e20              CMP      r6,#0x20
000036  d11c              BNE      |L28.114|
000038  e015              B        |L28.102|
                  |L28.58|
00003a  2e30              CMP      r6,#0x30
00003c  d014              BEQ      |L28.104|
00003e  2e38              CMP      r6,#0x38
000040  d117              BNE      |L28.114|
000042  e017              B        |L28.116|
                  |L28.68|
;;;459            {
;;;460                case 0x08:
;;;461                    I2C_SET_DATA(i2c, (u8SlaveAddr << 1 | 0x00));    /* Write SLA+W to Register I2CDAT */
000044  004e              LSLS     r6,r1,#1
000046  60a6              STR      r6,[r4,#8]
;;;462                    u8Ctrl = I2C_CTL_SI;                           /* Clear SI */
000048  2608              MOVS     r6,#8
00004a  9600              STR      r6,[sp,#0]
;;;463                    break;
00004c  e017              B        |L28.126|
                  |L28.78|
;;;464                case 0x18:                                           /* Slave Address ACK */
;;;465                case 0x28:                                           
00004e  bf00              NOP      
                  |L28.80|
;;;466                    if(u32txLen<u32wLen)
000050  4298              CMP      r0,r3
000052  d204              BCS      |L28.94|
;;;467                        I2C_SET_DATA(i2c, data[u32txLen++]);                /* Write Data to I2CDAT */
000054  4606              MOV      r6,r0
000056  1c40              ADDS     r0,r0,#1
000058  5d96              LDRB     r6,[r2,r6]
00005a  60a6              STR      r6,[r4,#8]
00005c  e002              B        |L28.100|
                  |L28.94|
;;;468                    else
;;;469                    {
;;;470                        u8Ctrl = I2C_CTL_STO_SI;                   /* Clear SI and send STOP */
00005e  2618              MOVS     r6,#0x18
000060  9600              STR      r6,[sp,#0]
;;;471                        u8Xfering = 0;
000062  2500              MOVS     r5,#0
                  |L28.100|
;;;472                    }
;;;473                    break;
000064  e00b              B        |L28.126|
                  |L28.102|
;;;474                case 0x20:                                           /* Slave Address NACK */
;;;475                case 0x30:                                           /* Master transmit data NACK */                
000066  bf00              NOP      
                  |L28.104|
;;;476                    u8Ctrl = I2C_CTL_STO_SI;                       /* Clear SI and send STOP */                
000068  2618              MOVS     r6,#0x18
00006a  9600              STR      r6,[sp,#0]
;;;477                    u8Err = 1;                
00006c  2601              MOVS     r6,#1
00006e  9601              STR      r6,[sp,#4]
;;;478                    break;                 
000070  e005              B        |L28.126|
                  |L28.114|
;;;479                case 0x38:                                           /* Arbitration Lost */
000072  bf00              NOP      
                  |L28.116|
;;;480                default:                                             /* Unknow status */
;;;481                    u8Ctrl = I2C_CTL_STO_SI;                       /* Clear SI and send STOP */                  
000074  2618              MOVS     r6,#0x18
000076  9600              STR      r6,[sp,#0]
;;;482                    u8Err = 1;
000078  2601              MOVS     r6,#1
00007a  9601              STR      r6,[sp,#4]
;;;483                    break;
00007c  bf00              NOP      
                  |L28.126|
00007e  bf00              NOP                            ;463
;;;484            }
;;;485            I2C_SET_CONTROL_REG(i2c, u8Ctrl);                        /* Write controlbit to I2C_CTL register */ 
000080  6826              LDR      r6,[r4,#0]
000082  273c              MOVS     r7,#0x3c
000084  43be              BICS     r6,r6,r7
000086  9f00              LDR      r7,[sp,#0]
000088  433e              ORRS     r6,r6,r7
00008a  6026              STR      r6,[r4,#0]
                  |L28.140|
00008c  2d00              CMP      r5,#0                 ;455
00008e  d002              BEQ      |L28.150|
000090  9e01              LDR      r6,[sp,#4]            ;455
000092  2e00              CMP      r6,#0                 ;455
000094  d0c0              BEQ      |L28.24|
                  |L28.150|
;;;486        }   
;;;487        return u32txLen;                                             /* Return bytes length that have been transmitted */
;;;488    }
000096  bdfc              POP      {r2-r7,pc}
;;;489    
                          ENDP


                          AREA ||i.I2C_WriteMultiBytesOneReg||, CODE, READONLY, ALIGN=1

                  I2C_WriteMultiBytesOneReg PROC
;;;566    
;;;567    uint32_t I2C_WriteMultiBytesOneReg(I2C_T *i2c, uint8_t u8SlaveAddr, uint8_t u8DataAddr, const uint8_t *data, uint32_t u32wLen)
000000  b5fc              PUSH     {r2-r7,lr}
;;;568    {
000002  4604              MOV      r4,r0
;;;569        uint8_t u8Xfering = 1, u8Err = 0, u8Ctrl = 0;
000004  2501              MOVS     r5,#1
000006  2600              MOVS     r6,#0
000008  9601              STR      r6,[sp,#4]
00000a  9600              STR      r6,[sp,#0]
;;;570        uint32_t u32txLen = 0;
00000c  2000              MOVS     r0,#0
;;;571      
;;;572        I2C_START(i2c);                                              /* Send START */
00000e  6826              LDR      r6,[r4,#0]
000010  2728              MOVS     r7,#0x28
000012  433e              ORRS     r6,r6,r7
000014  6026              STR      r6,[r4,#0]
;;;573        while(u8Xfering && (u8Err == 0))
000016  e03b              B        |L29.144|
                  |L29.24|
;;;574        {
;;;575            I2C_WAIT_READY(i2c);
000018  bf00              NOP      
                  |L29.26|
00001a  6826              LDR      r6,[r4,#0]
00001c  2708              MOVS     r7,#8
00001e  403e              ANDS     r6,r6,r7
000020  2e00              CMP      r6,#0
000022  d0fa              BEQ      |L29.26|
;;;576            switch(I2C_GET_STATUS(i2c))
000024  68e6              LDR      r6,[r4,#0xc]
000026  2e28              CMP      r6,#0x28
000028  d019              BEQ      |L29.94|
00002a  dc06              BGT      |L29.58|
00002c  2e08              CMP      r6,#8
00002e  d009              BEQ      |L29.68|
000030  2e18              CMP      r6,#0x18
000032  d00c              BEQ      |L29.78|
000034  2e20              CMP      r6,#0x20
000036  d11e              BNE      |L29.118|
000038  e00b              B        |L29.82|
                  |L29.58|
00003a  2e30              CMP      r6,#0x30
00003c  d00a              BEQ      |L29.84|
00003e  2e38              CMP      r6,#0x38
000040  d119              BNE      |L29.118|
000042  e019              B        |L29.120|
                  |L29.68|
;;;577            {
;;;578                case 0x08:
;;;579                    I2C_SET_DATA(i2c, (u8SlaveAddr << 1 | 0x00));    /* Write SLA+W to Register I2CDAT */
000044  004e              LSLS     r6,r1,#1
000046  60a6              STR      r6,[r4,#8]
;;;580                    u8Ctrl = I2C_CTL_SI;                 
000048  2608              MOVS     r6,#8
00004a  9600              STR      r6,[sp,#0]
;;;581                    break;
00004c  e019              B        |L29.130|
                  |L29.78|
;;;582                case 0x18:                                           /* Slave Address ACK */
;;;583                    I2C_SET_DATA(i2c, u8DataAddr);                   /* Write Lo byte address of register */
00004e  60a2              STR      r2,[r4,#8]
;;;584                    break;
000050  e017              B        |L29.130|
                  |L29.82|
;;;585                case 0x20:                                           /* Slave Address NACK */
;;;586                case 0x30:                                           /* Master transmit data NACK */                
000052  bf00              NOP      
                  |L29.84|
;;;587                    u8Ctrl = I2C_CTL_STO_SI;                       /* Clear SI and send STOP */                
000054  2618              MOVS     r6,#0x18
000056  9600              STR      r6,[sp,#0]
;;;588                    u8Err = 1;                
000058  2601              MOVS     r6,#1
00005a  9601              STR      r6,[sp,#4]
;;;589                    break;             
00005c  e011              B        |L29.130|
                  |L29.94|
;;;590                case 0x28:
;;;591                    if(u32txLen < u32wLen)
00005e  9e07              LDR      r6,[sp,#0x1c]
000060  42b0              CMP      r0,r6
000062  d204              BCS      |L29.110|
;;;592                        I2C_SET_DATA(i2c, data[u32txLen++]);
000064  4606              MOV      r6,r0
000066  1c40              ADDS     r0,r0,#1
000068  5d9e              LDRB     r6,[r3,r6]
00006a  60a6              STR      r6,[r4,#8]
00006c  e002              B        |L29.116|
                  |L29.110|
;;;593                    else
;;;594                    {
;;;595                        u8Ctrl = I2C_CTL_STO_SI;                   /* Clear SI and send STOP */
00006e  2618              MOVS     r6,#0x18
000070  9600              STR      r6,[sp,#0]
;;;596                        u8Xfering = 0;  
000072  2500              MOVS     r5,#0
                  |L29.116|
;;;597                    }                 
;;;598                    break;
000074  e005              B        |L29.130|
                  |L29.118|
;;;599                case 0x38:                                           /* Arbitration Lost */
000076  bf00              NOP      
                  |L29.120|
;;;600                default:                                             /* Unknow status */
;;;601                    u8Ctrl = I2C_CTL_STO_SI;                       /* Clear SI and send STOP */                  
000078  2618              MOVS     r6,#0x18
00007a  9600              STR      r6,[sp,#0]
;;;602                    u8Err = 1;  
00007c  2601              MOVS     r6,#1
00007e  9601              STR      r6,[sp,#4]
;;;603                    break;
000080  bf00              NOP      
                  |L29.130|
000082  bf00              NOP                            ;581
;;;604            }
;;;605            I2C_SET_CONTROL_REG(i2c, u8Ctrl);                        /* Write controlbit to I2C_CTL register */ 
000084  6826              LDR      r6,[r4,#0]
000086  273c              MOVS     r7,#0x3c
000088  43be              BICS     r6,r6,r7
00008a  9f00              LDR      r7,[sp,#0]
00008c  433e              ORRS     r6,r6,r7
00008e  6026              STR      r6,[r4,#0]
                  |L29.144|
000090  2d00              CMP      r5,#0                 ;573
000092  d002              BEQ      |L29.154|
000094  9e01              LDR      r6,[sp,#4]            ;573
000096  2e00              CMP      r6,#0                 ;573
000098  d0be              BEQ      |L29.24|
                  |L29.154|
;;;606        } 
;;;607        
;;;608        return u32txLen;                                             /* Return bytes length that have been transmitted */
;;;609    }
00009a  bdfc              POP      {r2-r7,pc}
;;;610    
                          ENDP


                          AREA ||i.I2C_WriteMultiBytesTwoRegs||, CODE, READONLY, ALIGN=1

                  I2C_WriteMultiBytesTwoRegs PROC
;;;692    
;;;693    uint32_t I2C_WriteMultiBytesTwoRegs(I2C_T *i2c, uint8_t u8SlaveAddr, uint16_t u16DataAddr, const uint8_t *data, uint32_t u32wLen)
000000  b5fe              PUSH     {r1-r7,lr}
;;;694    {
000002  4604              MOV      r4,r0
;;;695        uint8_t u8Xfering = 1, u8Err = 0, u8Addr = 1, u8Ctrl = 0;
000004  2601              MOVS     r6,#1
000006  9602              STR      r6,[sp,#8]
000008  2600              MOVS     r6,#0
00000a  9601              STR      r6,[sp,#4]
00000c  2501              MOVS     r5,#1
00000e  9600              STR      r6,[sp,#0]
;;;696        uint32_t u32txLen = 0;
000010  2000              MOVS     r0,#0
;;;697       
;;;698        I2C_START(i2c);                                                         /* Send START */
000012  6826              LDR      r6,[r4,#0]
000014  2728              MOVS     r7,#0x28
000016  433e              ORRS     r6,r6,r7
000018  6026              STR      r6,[r4,#0]
;;;699        while(u8Xfering && (u8Err == 0))
00001a  e049              B        |L30.176|
                  |L30.28|
;;;700        {
;;;701            I2C_WAIT_READY(i2c);
00001c  bf00              NOP      
                  |L30.30|
00001e  6826              LDR      r6,[r4,#0]
000020  2708              MOVS     r7,#8
000022  403e              ANDS     r6,r6,r7
000024  2e00              CMP      r6,#0
000026  d0fa              BEQ      |L30.30|
;;;702            switch(I2C_GET_STATUS(i2c))
000028  68e6              LDR      r6,[r4,#0xc]
00002a  2e28              CMP      r6,#0x28
00002c  d01e              BEQ      |L30.108|
00002e  dc06              BGT      |L30.62|
000030  2e08              CMP      r6,#8
000032  d009              BEQ      |L30.72|
000034  2e18              CMP      r6,#0x18
000036  d00c              BEQ      |L30.82|
000038  2e20              CMP      r6,#0x20
00003a  d12c              BNE      |L30.150|
00003c  e010              B        |L30.96|
                  |L30.62|
00003e  2e30              CMP      r6,#0x30
000040  d00f              BEQ      |L30.98|
000042  2e38              CMP      r6,#0x38
000044  d127              BNE      |L30.150|
000046  e027              B        |L30.152|
                  |L30.72|
;;;703            {
;;;704                case 0x08:
;;;705                    I2C_SET_DATA(i2c, (u8SlaveAddr << 1 | 0x00));               /* Write SLA+W to Register I2CDAT */
000048  004e              LSLS     r6,r1,#1
00004a  60a6              STR      r6,[r4,#8]
;;;706                    u8Ctrl = I2C_CTL_SI;                                      /* Clear SI */                 
00004c  2608              MOVS     r6,#8
00004e  9600              STR      r6,[sp,#0]
;;;707                    break;
000050  e027              B        |L30.162|
                  |L30.82|
;;;708                case 0x18:                                                      /* Slave Address ACK */
;;;709                    I2C_SET_DATA(i2c, (uint8_t)(u16DataAddr & 0xFF00) >> 8);    /* Write Hi byte address of register */
000052  26ff              MOVS     r6,#0xff
000054  0236              LSLS     r6,r6,#8
000056  4016              ANDS     r6,r6,r2
000058  b2f6              UXTB     r6,r6
00005a  1236              ASRS     r6,r6,#8
00005c  60a6              STR      r6,[r4,#8]
;;;710                    break;
00005e  e020              B        |L30.162|
                  |L30.96|
;;;711                case 0x20:                                                      /* Slave Address NACK */
;;;712                case 0x30:                                                      /* Master transmit data NACK */                
000060  bf00              NOP      
                  |L30.98|
;;;713                    u8Ctrl = I2C_CTL_STO_SI;                                  /* Clear SI and send STOP */                
000062  2618              MOVS     r6,#0x18
000064  9600              STR      r6,[sp,#0]
;;;714                    u8Err = 1;                
000066  2601              MOVS     r6,#1
000068  9601              STR      r6,[sp,#4]
;;;715                    break;  
00006a  e01a              B        |L30.162|
                  |L30.108|
;;;716                case 0x28:
;;;717                    if(u8Addr)
00006c  2d00              CMP      r5,#0
00006e  d003              BEQ      |L30.120|
;;;718                    {
;;;719                        I2C_SET_DATA(i2c, (uint8_t)(u16DataAddr & 0xFF));       /* Write Lo byte address of register */
000070  b2d6              UXTB     r6,r2
000072  60a6              STR      r6,[r4,#8]
;;;720                        u8Addr = 0;
000074  2500              MOVS     r5,#0
000076  e00d              B        |L30.148|
                  |L30.120|
;;;721                    }
;;;722                    else if((u32txLen < u32wLen) && (u8Addr == 0))
000078  9e08              LDR      r6,[sp,#0x20]
00007a  42b0              CMP      r0,r6
00007c  d206              BCS      |L30.140|
00007e  2d00              CMP      r5,#0
000080  d104              BNE      |L30.140|
;;;723                        I2C_SET_DATA(i2c, data[u32txLen++]);                           /* Write data to Register I2CDAT*/
000082  4606              MOV      r6,r0
000084  1c40              ADDS     r0,r0,#1
000086  5d9e              LDRB     r6,[r3,r6]
000088  60a6              STR      r6,[r4,#8]
00008a  e003              B        |L30.148|
                  |L30.140|
;;;724                    else
;;;725                    {
;;;726                        u8Ctrl = I2C_CTL_STO_SI;                              /* Clear SI and send STOP */
00008c  2618              MOVS     r6,#0x18
00008e  9600              STR      r6,[sp,#0]
;;;727                        u8Xfering = 0;
000090  2600              MOVS     r6,#0
000092  9602              STR      r6,[sp,#8]
                  |L30.148|
;;;728                    }                 
;;;729                    break;
000094  e005              B        |L30.162|
                  |L30.150|
;;;730                case 0x38:                                                      /* Arbitration Lost */
000096  bf00              NOP      
                  |L30.152|
;;;731                default:                                                        /* Unknow status */
;;;732                    u8Ctrl = I2C_CTL_STO_SI;                                  /* Clear SI and send STOP */                  
000098  2618              MOVS     r6,#0x18
00009a  9600              STR      r6,[sp,#0]
;;;733                    u8Err = 1;
00009c  2601              MOVS     r6,#1
00009e  9601              STR      r6,[sp,#4]
;;;734                    break;
0000a0  bf00              NOP      
                  |L30.162|
0000a2  bf00              NOP                            ;707
;;;735            }
;;;736            I2C_SET_CONTROL_REG(i2c, u8Ctrl);                                   /* Write controlbit to I2C_CTL register */ 
0000a4  6826              LDR      r6,[r4,#0]
0000a6  273c              MOVS     r7,#0x3c
0000a8  43be              BICS     r6,r6,r7
0000aa  9f00              LDR      r7,[sp,#0]
0000ac  433e              ORRS     r6,r6,r7
0000ae  6026              STR      r6,[r4,#0]
                  |L30.176|
0000b0  9e02              LDR      r6,[sp,#8]            ;699
0000b2  2e00              CMP      r6,#0                 ;699
0000b4  d002              BEQ      |L30.188|
0000b6  9e01              LDR      r6,[sp,#4]            ;699
0000b8  2e00              CMP      r6,#0                 ;699
0000ba  d0af              BEQ      |L30.28|
                  |L30.188|
;;;737        }
;;;738        return u32txLen;                                                        /* Return bytes length that have been transmitted */
;;;739    }
0000bc  bdfe              POP      {r1-r7,pc}
;;;740    
                          ENDP


                          AREA ||i.__ARM_common_switch8||, COMGROUP=__ARM_common_switch8, CODE, READONLY, ALIGN=1

                  __ARM_common_switch8 PROC
000000  b430              PUSH     {r4,r5}
000002  4674              MOV      r4,lr
000004  1e64              SUBS     r4,r4,#1
000006  7825              LDRB     r5,[r4,#0]
000008  1c64              ADDS     r4,r4,#1
00000a  42ab              CMP      r3,r5
00000c  d304              BCC      |L187.24|
                  |L187.14|
00000e  5d63              LDRB     r3,[r4,r5]
000010  005b              LSLS     r3,r3,#1
000012  18e3              ADDS     r3,r4,r3
000014  bc30              POP      {r4,r5}
000016  4718              BX       r3
                  |L187.24|
000018  461d              MOV      r5,r3
00001a  e7f8              B        |L187.14|
                          ENDP


;*** Start embedded assembler ***

#line 1 "..\\..\\..\\NUC126_Series_BSP_CMSIS_V3.00.005\\Library\\StdDriver\\src\\i2c.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___5_i2c_c_I2C_Open____REV16|
#line 388 "..\\..\\..\\NUC126_Series_BSP_CMSIS_V3.00.005\\Library\\CMSIS\\Include\\cmsis_armcc.h"
|__asm___5_i2c_c_I2C_Open____REV16| PROC
#line 389

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___5_i2c_c_I2C_Open____REVSH|
#line 402
|__asm___5_i2c_c_I2C_Open____REVSH| PROC
#line 403

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
