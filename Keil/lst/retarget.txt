; generated by Component: ARM Compiler 5.05 update 1 (build 106) Tool: ArmCC [4d0efa]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\obj\retarget.o --asm_dir=.\lst\ --list_dir=.\lst\ --depend=.\obj\retarget.d --cpu=Cortex-M0 --apcs=interwork -O0 --diag_suppress=9931 -I..\..\..\Library\CMSIS\Include -I..\..\..\Library\Device\Nuvoton\NUC126\Include -I..\..\..\Library\StdDriver\inc -I..\..\..\NUC126_Series_BSP_CMSIS_V3.00.005\Library\StdDriver\inc -I..\..\..\NUC126_Series_BSP_CMSIS_V3.00.005\Library\Device\Nuvoton\NUC126\Include -I..\..\..\NUC126_Series_BSP_CMSIS_V3.00.005\Library\CMSIS\Include -IC:\Keil_v5\ARM\RV31\INC -IC:\Keil_v5\ARM\CMSIS\Include -D__MICROLIB -D__UVISION_VERSION=514 --omf_browse=.\obj\retarget.crf ..\..\..\NUC126_Series_BSP_CMSIS_V3.00.005\Library\StdDriver\src\retarget.c]
                          THUMB

                          AREA ||i.GetChar||, CODE, READONLY, ALIGN=2

                  GetChar PROC
;;;555     */
;;;556    char GetChar(void)
000000  e00a              B        |L1.24|
                  |L1.2|
;;;557    {
;;;558    #ifdef DEBUG_ENABLE_SEMIHOST
;;;559    # if defined ( __CC_ARM   )
;;;560        int nRet;
;;;561        while(SH_DoCommand(0x101, 0, &nRet) != 0)
;;;562        {
;;;563            if(nRet != 0)
;;;564            {
;;;565                SH_DoCommand(0x07, 0, &nRet);
;;;566                return (char)nRet;
;;;567            }
;;;568        }
;;;569    # else
;;;570        int nRet;
;;;571        while(SH_DoCommand(0x7, 0, &nRet) != 0)
;;;572        {
;;;573            if(nRet != 0)
;;;574                return (char)nRet;
;;;575        }
;;;576    # endif
;;;577        return (0);
;;;578    #else
;;;579    
;;;580        while(1)
;;;581        {
;;;582            if((DEBUG_PORT->FIFOSTS & UART_FIFOSTS_RXEMPTY_Msk) == 0)
000002  4806              LDR      r0,|L1.28|
000004  6980              LDR      r0,[r0,#0x18]
000006  2101              MOVS     r1,#1
000008  0389              LSLS     r1,r1,#14
00000a  4008              ANDS     r0,r0,r1
00000c  2800              CMP      r0,#0
00000e  d103              BNE      |L1.24|
;;;583            {
;;;584                return (DEBUG_PORT->DAT);
000010  4802              LDR      r0,|L1.28|
000012  6800              LDR      r0,[r0,#0]
000014  b2c0              UXTB     r0,r0
;;;585            }
;;;586        }
;;;587    
;;;588    #endif
;;;589    }
000016  4770              BX       lr
                  |L1.24|
000018  e7f3              B        |L1.2|
;;;590    
                          ENDP

00001a  0000              DCW      0x0000
                  |L1.28|
                          DCD      0x40154000

                          AREA ||i.Hard_Fault_Handler||, CODE, READONLY, ALIGN=2

                  Hard_Fault_Handler PROC
                  ||__tagsym$$used||
;;;64      */
;;;65     void Hard_Fault_Handler(uint32_t stack[])
000000  b510              PUSH     {r4,lr}
;;;66     {
000002  4604              MOV      r4,r0
;;;67         printf("In Hard Fault Handler\n");
000004  a004              ADR      r0,|L2.24|
000006  f7fffffe          BL       __2printf
;;;68     
;;;69         stackDump(stack);
00000a  4620              MOV      r0,r4
00000c  f7fffffe          BL       stackDump
;;;70     
;;;71         // Replace while(1) with chip reset if WDT is not enabled for end product
;;;72     		//NVIC_SystemReset();	// Barry 
;;;73     		SYS_ResetChip();
000010  f7fffffe          BL       SYS_ResetChip
;;;74         //while(1);
;;;75         //SYS->IPRSTC1 = SYS_IPRSTC1_CHIP_RST_Msk;
;;;76     }
000014  bd10              POP      {r4,pc}
;;;77     
                          ENDP

000016  0000              DCW      0x0000
                  |L2.24|
000018  496e2048          DCB      "In Hard Fault Handler\n",0
00001c  61726420
000020  4661756c
000024  74204861
000028  6e646c65
00002c  720a00  
00002f  00                DCB      0

                          AREA ||i.IsDebugFifoEmpty||, CODE, READONLY, ALIGN=2

                  IsDebugFifoEmpty PROC
;;;616    
;;;617    int IsDebugFifoEmpty(void)
000000  4803              LDR      r0,|L3.16|
;;;618    {
;;;619        return ((DEBUG_PORT->FIFOSTS & UART_FIFOSTS_TXEMPTYF_Msk) != 0);
000002  6980              LDR      r0,[r0,#0x18]
000004  2101              MOVS     r1,#1
000006  0709              LSLS     r1,r1,#28
000008  4008              ANDS     r0,r0,r1
00000a  0f00              LSRS     r0,r0,#28
;;;620    }
00000c  4770              BX       lr
;;;621    
                          ENDP

00000e  0000              DCW      0x0000
                  |L3.16|
                          DCD      0x40154000

                          AREA ||i.SendChar||, CODE, READONLY, ALIGN=1

                  SendChar PROC
;;;523     */
;;;524    void SendChar(int ch)
000000  b500              PUSH     {lr}
;;;525    {
000002  4603              MOV      r3,r0
;;;526    #if defined(DEBUG_ENABLE_SEMIHOST)
;;;527        g_buf[g_buf_len++] = ch;
;;;528        g_buf[g_buf_len] = '\0';
;;;529        if(g_buf_len + 1 >= sizeof(g_buf) || ch == '\n' || ch == '\0')
;;;530        {
;;;531            /* Send the char */
;;;532            if(SH_DoCommand(0x04, (int)g_buf, NULL) != 0)
;;;533            {
;;;534                g_buf_len = 0;
;;;535                return;
;;;536            }
;;;537            else
;;;538            {
;;;539                g_buf_len = 0;
;;;540            }
;;;541        }
;;;542    #else
;;;543        SendChar_ToUART(ch);
000004  4618              MOV      r0,r3
000006  f7fffffe          BL       SendChar_ToUART
;;;544    #endif
;;;545    }
00000a  bd00              POP      {pc}
;;;546    
                          ENDP


                          AREA ||i.SendChar_ToUART||, CODE, READONLY, ALIGN=2

                  SendChar_ToUART PROC
;;;440    
;;;441    void SendChar_ToUART(int ch)
000000  bf00              NOP      
                  |L5.2|
;;;442    {
;;;443    
;;;444        while(DEBUG_PORT->FIFOSTS & UART_FIFOSTS_TXFULL_Msk);
000002  490b              LDR      r1,|L5.48|
000004  6989              LDR      r1,[r1,#0x18]
000006  2201              MOVS     r2,#1
000008  05d2              LSLS     r2,r2,#23
00000a  4011              ANDS     r1,r1,r2
00000c  2900              CMP      r1,#0
00000e  d1f8              BNE      |L5.2|
;;;445    
;;;446        if(ch == '\n')
000010  280a              CMP      r0,#0xa
000012  d10a              BNE      |L5.42|
;;;447        {
;;;448            DEBUG_PORT->DAT = '\r';
000014  210d              MOVS     r1,#0xd
000016  4a06              LDR      r2,|L5.48|
000018  6011              STR      r1,[r2,#0]
;;;449            while(DEBUG_PORT->FIFOSTS & UART_FIFOSTS_TXFULL_Msk);
00001a  bf00              NOP      
                  |L5.28|
00001c  4904              LDR      r1,|L5.48|
00001e  6989              LDR      r1,[r1,#0x18]
000020  2201              MOVS     r2,#1
000022  05d2              LSLS     r2,r2,#23
000024  4011              ANDS     r1,r1,r2
000026  2900              CMP      r1,#0
000028  d1f8              BNE      |L5.28|
                  |L5.42|
;;;450        }
;;;451    
;;;452        DEBUG_PORT->DAT = ch;
00002a  4901              LDR      r1,|L5.48|
00002c  6008              STR      r0,[r1,#0]
;;;453    }
00002e  4770              BX       lr
;;;454    #else
                          ENDP

                  |L5.48|
                          DCD      0x40154000

                          AREA ||i._ttywrch||, CODE, READONLY, ALIGN=1

                  _ttywrch PROC
;;;631    
;;;632    void _ttywrch(int ch)
000000  b510              PUSH     {r4,lr}
;;;633    {
000002  4604              MOV      r4,r0
;;;634        SendChar(ch);
000004  4620              MOV      r0,r4
000006  f7fffffe          BL       SendChar
;;;635        return;
;;;636    }
00000a  bd10              POP      {r4,pc}
;;;637    
                          ENDP


                          AREA ||i.ferror||, CODE, READONLY, ALIGN=1

                  ferror PROC
;;;730    
;;;731    int ferror(FILE *stream)
000000  4601              MOV      r1,r0
;;;732    {
;;;733        return EOF;
000002  2000              MOVS     r0,#0
000004  43c0              MVNS     r0,r0
;;;734    }
000006  4770              BX       lr
;;;735    #endif
                          ENDP


                          AREA ||i.fgetc||, CODE, READONLY, ALIGN=1

                  fgetc PROC
;;;710    
;;;711    int fgetc(FILE *stream)
000000  b500              PUSH     {lr}
;;;712    {
000002  4602              MOV      r2,r0
;;;713        return (GetChar());
000004  f7fffffe          BL       GetChar
;;;714    }
000008  bd00              POP      {pc}
;;;715    
                          ENDP


                          AREA ||i.fputc||, CODE, READONLY, ALIGN=1

                  fputc PROC
;;;656    
;;;657    int fputc(int ch, FILE *stream)
000000  b530              PUSH     {r4,r5,lr}
;;;658    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;659        (void) stream;
;;;660        SendChar(ch);
000006  4620              MOV      r0,r4
000008  f7fffffe          BL       SendChar
;;;661        return ch;
00000c  4620              MOV      r0,r4
;;;662    }
00000e  bd30              POP      {r4,r5,pc}
;;;663    
                          ENDP


                          AREA ||i.kbhit||, CODE, READONLY, ALIGN=2

                  kbhit PROC
;;;601    
;;;602    int kbhit(void)
000000  4803              LDR      r0,|L10.16|
;;;603    {
;;;604        return !((DEBUG_PORT->FIFOSTS & UART_FIFOSTS_RXEMPTY_Msk) == 0);
000002  6980              LDR      r0,[r0,#0x18]
000004  2101              MOVS     r1,#1
000006  0389              LSLS     r1,r1,#14
000008  4008              ANDS     r0,r0,r1
00000a  0b80              LSRS     r0,r0,#14
;;;605    }
00000c  4770              BX       lr
;;;606    /**
                          ENDP

00000e  0000              DCW      0x0000
                  |L10.16|
                          DCD      0x40154000

                          AREA ||i.stackDump||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_sizespec
                          REQUIRE _printf_percent
                          REQUIRE _printf_x
                          REQUIRE _printf_longlong_hex
                  stackDump PROC
;;;46      */
;;;47     static void stackDump(uint32_t stack[])
000000  b510              PUSH     {r4,lr}
;;;48     {
000002  4604              MOV      r4,r0
;;;49         printf("r0  = 0x%lx\n", stack[r0]);
000004  a010              ADR      r0,|L11.72|
000006  6821              LDR      r1,[r4,#0]
000008  f7fffffe          BL       __2printf
;;;50         printf("r1  = 0x%lx\n", stack[r1]);
00000c  a012              ADR      r0,|L11.88|
00000e  6861              LDR      r1,[r4,#4]
000010  f7fffffe          BL       __2printf
;;;51         printf("r2  = 0x%lx\n", stack[r2]);
000014  a014              ADR      r0,|L11.104|
000016  68a1              LDR      r1,[r4,#8]
000018  f7fffffe          BL       __2printf
;;;52         printf("r3  = 0x%lx\n", stack[r3]);
00001c  a016              ADR      r0,|L11.120|
00001e  68e1              LDR      r1,[r4,#0xc]
000020  f7fffffe          BL       __2printf
;;;53         printf("r12 = 0x%lx\n", stack[r12]);
000024  a018              ADR      r0,|L11.136|
000026  6921              LDR      r1,[r4,#0x10]
000028  f7fffffe          BL       __2printf
;;;54         printf("lr  = 0x%lx\n", stack[lr]);
00002c  a01a              ADR      r0,|L11.152|
00002e  6961              LDR      r1,[r4,#0x14]
000030  f7fffffe          BL       __2printf
;;;55         printf("pc  = 0x%lx\n", stack[pc]);
000034  a01c              ADR      r0,|L11.168|
000036  69a1              LDR      r1,[r4,#0x18]
000038  f7fffffe          BL       __2printf
;;;56         printf("psr = 0x%lx\n", stack[psr]);
00003c  a01e              ADR      r0,|L11.184|
00003e  69e1              LDR      r1,[r4,#0x1c]
000040  f7fffffe          BL       __2printf
;;;57     }
000044  bd10              POP      {r4,pc}
;;;58     
                          ENDP

000046  0000              DCW      0x0000
                  |L11.72|
000048  72302020          DCB      "r0  = 0x%lx\n",0
00004c  3d203078
000050  256c780a
000054  00      
000055  00                DCB      0
000056  00                DCB      0
000057  00                DCB      0
                  |L11.88|
000058  72312020          DCB      "r1  = 0x%lx\n",0
00005c  3d203078
000060  256c780a
000064  00      
000065  00                DCB      0
000066  00                DCB      0
000067  00                DCB      0
                  |L11.104|
000068  72322020          DCB      "r2  = 0x%lx\n",0
00006c  3d203078
000070  256c780a
000074  00      
000075  00                DCB      0
000076  00                DCB      0
000077  00                DCB      0
                  |L11.120|
000078  72332020          DCB      "r3  = 0x%lx\n",0
00007c  3d203078
000080  256c780a
000084  00      
000085  00                DCB      0
000086  00                DCB      0
000087  00                DCB      0
                  |L11.136|
000088  72313220          DCB      "r12 = 0x%lx\n",0
00008c  3d203078
000090  256c780a
000094  00      
000095  00                DCB      0
000096  00                DCB      0
000097  00                DCB      0
                  |L11.152|
000098  6c722020          DCB      "lr  = 0x%lx\n",0
00009c  3d203078
0000a0  256c780a
0000a4  00      
0000a5  00                DCB      0
0000a6  00                DCB      0
0000a7  00                DCB      0
                  |L11.168|
0000a8  70632020          DCB      "pc  = 0x%lx\n",0
0000ac  3d203078
0000b0  256c780a
0000b4  00      
0000b5  00                DCB      0
0000b6  00                DCB      0
0000b7  00                DCB      0
                  |L11.184|
0000b8  70737220          DCB      "psr = 0x%lx\n",0
0000bc  3d203078
0000c0  256c780a
0000c4  00      
0000c5  00                DCB      0
0000c6  00                DCB      0
0000c7  00                DCB      0

                          AREA ||.data||, DATA, ALIGN=2

                  __stdout
                          DCD      0x00000000
                  __stdin
                          DCD      0x00000000

;*** Start embedded assembler ***

#line 1 "..\\..\\..\\NUC126_Series_BSP_CMSIS_V3.00.005\\Library\\StdDriver\\src\\retarget.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___10_retarget_c_d5a1b03f____REV16|
#line 388 "..\\..\\..\\NUC126_Series_BSP_CMSIS_V3.00.005\\Library\\CMSIS\\Include\\cmsis_armcc.h"
|__asm___10_retarget_c_d5a1b03f____REV16| PROC
#line 389

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___10_retarget_c_d5a1b03f____REVSH|
#line 402
|__asm___10_retarget_c_d5a1b03f____REVSH| PROC
#line 403

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.emb_text||, CODE
	THUMB
	EXPORT |HardFault_Handler|
#line 405 "..\\..\\..\\NUC126_Series_BSP_CMSIS_V3.00.005\\Library\\StdDriver\\src\\retarget.c"
|HardFault_Handler| PROC
#line 406

 IMPORT Hard_Fault_Handler

 MOVS r0, #4
 MOV r1, LR
 TST r0, r1  
 BEQ Stack_Use_MSP  
 MRS R0, PSP  
 B Get_LR_and_Branch
Stack_Use_MSP
 MRS R0, MSP  
Get_LR_and_Branch
 MOV R1, LR  
 LDR R2, =  |Hard_Fault_Handler|  
 BX R2
	ENDP

;*** End   embedded assembler ***
